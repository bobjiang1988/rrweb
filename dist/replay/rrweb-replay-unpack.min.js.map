{"version":3,"file":"rrweb-replay-unpack.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../node_modules/rrweb-snapshot/es/rrweb-snapshot.js","../../node_modules/mitt/dist/mitt.es.js","../../src/types.ts","../../src/replay/smoothscroll.ts","../../src/replay/timer.ts","../../node_modules/@xstate/fsm/es/index.js","../../src/utils.ts","../../src/replay/machine.ts","../../src/replay/styles/inject-style.ts","../../src/replay/index.ts","../../node_modules/fflate/esm/browser.js","../../src/packer/unpack.ts","../../src/packer/base.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","var NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\n    return n.nodeType === n.ELEMENT_NODE;\n}\nfunction isShadowRoot(n) {\n    var _a;\n    var host = (_a = n) === null || _a === void 0 ? void 0 : _a.host;\n    return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\n\nvar _id = 1;\nvar tagNameRegex = RegExp('[^a-z0-9-_]');\nvar IGNORED_NODE = -2;\nfunction genId() {\n    return _id++;\n}\nfunction getValidTagName(element) {\n    if (element instanceof HTMLFormElement) {\n        return 'form';\n    }\n    var processedTagName = element.tagName.toLowerCase().trim();\n    if (tagNameRegex.test(processedTagName)) {\n        return 'div';\n    }\n    return processedTagName;\n}\nfunction getCssRulesString(s) {\n    try {\n        var rules = s.rules || s.cssRules;\n        return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n    }\n    catch (error) {\n        return null;\n    }\n}\nfunction getCssRuleString(rule) {\n    return isCSSImportRule(rule)\n        ? getCssRulesString(rule.styleSheet) || ''\n        : rule.cssText;\n}\nfunction isCSSImportRule(rule) {\n    return 'styleSheet' in rule;\n}\nfunction extractOrigin(url) {\n    var origin;\n    if (url.indexOf('//') > -1) {\n        origin = url.split('/').slice(0, 3).join('/');\n    }\n    else {\n        origin = url.split('/')[0];\n    }\n    origin = origin.split('?')[0];\n    return origin;\n}\nvar URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm;\nvar RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nvar DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n    return (cssText || '').replace(URL_IN_CSS_REF, function (origin, quote1, path1, quote2, path2, path3) {\n        var filePath = path1 || path2 || path3;\n        var maybeQuote = quote1 || quote2 || '';\n        if (!filePath) {\n            return origin;\n        }\n        if (!RELATIVE_PATH.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (DATA_URI.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (filePath[0] === '/') {\n            return \"url(\" + maybeQuote + (extractOrigin(href) + filePath) + maybeQuote + \")\";\n        }\n        var stack = href.split('/');\n        var parts = filePath.split('/');\n        stack.pop();\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            if (part === '.') {\n                continue;\n            }\n            else if (part === '..') {\n                stack.pop();\n            }\n            else {\n                stack.push(part);\n            }\n        }\n        return \"url(\" + maybeQuote + stack.join('/') + maybeQuote + \")\";\n    });\n}\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n    if (attributeValue.trim() === '') {\n        return attributeValue;\n    }\n    var srcsetValues = attributeValue.split(',');\n    var resultingSrcsetString = srcsetValues\n        .map(function (srcItem) {\n        var trimmedSrcItem = srcItem.trimLeft().trimRight();\n        var urlAndSize = trimmedSrcItem.split(' ');\n        if (urlAndSize.length === 2) {\n            var absUrl = absoluteToDoc(doc, urlAndSize[0]);\n            return absUrl + \" \" + urlAndSize[1];\n        }\n        else if (urlAndSize.length === 1) {\n            var absUrl = absoluteToDoc(doc, urlAndSize[0]);\n            return \"\" + absUrl;\n        }\n        return '';\n    })\n        .join(', ');\n    return resultingSrcsetString;\n}\nfunction absoluteToDoc(doc, attributeValue) {\n    if (!attributeValue || attributeValue.trim() === '') {\n        return attributeValue;\n    }\n    var a = doc.createElement('a');\n    a.href = attributeValue;\n    return a.href;\n}\nfunction isSVGElement(el) {\n    return el.tagName === 'svg' || el instanceof SVGElement;\n}\nfunction getHref() {\n    var a = document.createElement('a');\n    a.href = '';\n    return a.href;\n}\nfunction transformAttribute(doc, tagName, name, value) {\n    if (name === 'src' || ((name === 'href' || name === 'xlink:href') && value)) {\n        return absoluteToDoc(doc, value);\n    }\n    else if (name === 'background' &&\n        value &&\n        (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\n        return absoluteToDoc(doc, value);\n    }\n    else if (name === 'srcset' && value) {\n        return getAbsoluteSrcsetString(doc, value);\n    }\n    else if (name === 'style' && value) {\n        return absoluteToStylesheet(value, getHref());\n    }\n    else {\n        return value;\n    }\n}\nfunction _isBlockedElement(element, blockClass, blockSelector) {\n    if (typeof blockClass === 'string') {\n        if (element.classList.contains(blockClass)) {\n            return true;\n        }\n    }\n    else {\n        for (var eIndex = 0; eIndex < element.classList.length; eIndex++) {\n            var className = element.classList[eIndex];\n            if (blockClass.test(className)) {\n                return true;\n            }\n        }\n    }\n    if (blockSelector) {\n        return element.matches(blockSelector);\n    }\n    return false;\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector) {\n    if (!node) {\n        return false;\n    }\n    if (node.nodeType === node.ELEMENT_NODE) {\n        if (typeof maskTextClass === 'string') {\n            if (node.classList.contains(maskTextClass)) {\n                return true;\n            }\n        }\n        else {\n            node.classList.forEach(function (className) {\n                if (maskTextClass.test(className)) {\n                    return true;\n                }\n            });\n        }\n        if (maskTextSelector) {\n            if (node.matches(maskTextSelector)) {\n                return true;\n            }\n        }\n        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n    }\n    if (node.nodeType === node.TEXT_NODE) {\n        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n    }\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n    var win = iframeEl.contentWindow;\n    if (!win) {\n        return;\n    }\n    var fired = false;\n    var readyState;\n    try {\n        readyState = win.document.readyState;\n    }\n    catch (error) {\n        return;\n    }\n    if (readyState !== 'complete') {\n        var timer_1 = setTimeout(function () {\n            if (!fired) {\n                listener();\n                fired = true;\n            }\n        }, iframeLoadTimeout);\n        iframeEl.addEventListener('load', function () {\n            clearTimeout(timer_1);\n            fired = true;\n            listener();\n        });\n        return;\n    }\n    var blankUrl = 'about:blank';\n    if (win.location.href !== blankUrl ||\n        iframeEl.src === blankUrl ||\n        iframeEl.src === '') {\n        listener();\n        return;\n    }\n    iframeEl.addEventListener('load', listener);\n}\nfunction serializeNode(n, options) {\n    var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, inlineStylesheet = options.inlineStylesheet, _a = options.maskInputOptions, maskInputOptions = _a === void 0 ? {} : _a, maskTextFn = options.maskTextFn, recordCanvas = options.recordCanvas;\n    var rootId;\n    if (doc.__sn) {\n        var docId = doc.__sn.id;\n        rootId = docId === 1 ? undefined : docId;\n    }\n    switch (n.nodeType) {\n        case n.DOCUMENT_NODE:\n            return {\n                type: NodeType.Document,\n                childNodes: [],\n                rootId: rootId,\n            };\n        case n.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType.DocumentType,\n                name: n.name,\n                publicId: n.publicId,\n                systemId: n.systemId,\n                rootId: rootId,\n            };\n        case n.ELEMENT_NODE:\n            var needBlock = _isBlockedElement(n, blockClass, blockSelector);\n            var tagName = getValidTagName(n);\n            var attributes_1 = {};\n            for (var _i = 0, _b = Array.from(n.attributes); _i < _b.length; _i++) {\n                var _c = _b[_i], name = _c.name, value = _c.value;\n                attributes_1[name] = transformAttribute(doc, tagName, name, value);\n            }\n            if (tagName === 'link' && inlineStylesheet) {\n                var stylesheet = Array.from(doc.styleSheets).find(function (s) {\n                    return s.href === n.href;\n                });\n                var cssText = getCssRulesString(stylesheet);\n                if (cssText) {\n                    delete attributes_1.rel;\n                    delete attributes_1.href;\n                    attributes_1._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n                }\n            }\n            if (tagName === 'style' &&\n                n.sheet &&\n                !(n.innerText ||\n                    n.textContent ||\n                    '').trim().length) {\n                var cssText = getCssRulesString(n.sheet);\n                if (cssText) {\n                    attributes_1._cssText = absoluteToStylesheet(cssText, getHref());\n                }\n            }\n            if (tagName === 'input' ||\n                tagName === 'textarea' ||\n                tagName === 'select') {\n                var value = n.value;\n                if (attributes_1.type !== 'radio' &&\n                    attributes_1.type !== 'checkbox' &&\n                    attributes_1.type !== 'submit' &&\n                    attributes_1.type !== 'button' &&\n                    value) {\n                    attributes_1.value =\n                        maskInputOptions[attributes_1.type] ||\n                            maskInputOptions[tagName]\n                            ? '*'.repeat(value.length)\n                            : value;\n                }\n                else if (n.checked) {\n                    attributes_1.checked = n.checked;\n                }\n            }\n            if (tagName === 'option') {\n                var selectValue = n.parentElement;\n                if (attributes_1.value === selectValue.value) {\n                    attributes_1.selected = n.selected;\n                }\n            }\n            if (tagName === 'canvas' && recordCanvas) {\n                attributes_1.rr_dataURL = n.toDataURL();\n            }\n            if (tagName === 'audio' || tagName === 'video') {\n                attributes_1.rr_mediaState = n.paused\n                    ? 'paused'\n                    : 'played';\n            }\n            if (n.scrollLeft) {\n                attributes_1.rr_scrollLeft = n.scrollLeft;\n            }\n            if (n.scrollTop) {\n                attributes_1.rr_scrollTop = n.scrollTop;\n            }\n            if (needBlock) {\n                var _d = n.getBoundingClientRect(), width = _d.width, height = _d.height;\n                attributes_1 = {\n                    class: attributes_1.class,\n                    rr_width: width + \"px\",\n                    rr_height: height + \"px\",\n                };\n            }\n            if (tagName === 'iframe') {\n                delete attributes_1.src;\n            }\n            return {\n                type: NodeType.Element,\n                tagName: tagName,\n                attributes: attributes_1,\n                childNodes: [],\n                isSVG: isSVGElement(n) || undefined,\n                needBlock: needBlock,\n                rootId: rootId,\n            };\n        case n.TEXT_NODE:\n            var parentTagName = n.parentNode && n.parentNode.tagName;\n            var textContent = n.textContent;\n            var isStyle = parentTagName === 'STYLE' ? true : undefined;\n            var isScript = parentTagName === 'SCRIPT' ? true : undefined;\n            if (isStyle && textContent) {\n                textContent = absoluteToStylesheet(textContent, getHref());\n            }\n            if (isScript) {\n                textContent = 'SCRIPT_PLACEHOLDER';\n            }\n            if (!isStyle &&\n                !isScript &&\n                needMaskingText(n, maskTextClass, maskTextSelector) &&\n                textContent) {\n                textContent = maskTextFn\n                    ? maskTextFn(textContent)\n                    : textContent.replace(/[\\S]/g, '*');\n            }\n            return {\n                type: NodeType.Text,\n                textContent: textContent || '',\n                isStyle: isStyle,\n                rootId: rootId,\n            };\n        case n.CDATA_SECTION_NODE:\n            return {\n                type: NodeType.CDATA,\n                textContent: '',\n                rootId: rootId,\n            };\n        case n.COMMENT_NODE:\n            return {\n                type: NodeType.Comment,\n                textContent: n.textContent || '',\n                rootId: rootId,\n            };\n        default:\n            return false;\n    }\n}\nfunction lowerIfExists(maybeAttr) {\n    if (maybeAttr === undefined) {\n        return '';\n    }\n    else {\n        return maybeAttr.toLowerCase();\n    }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n        return true;\n    }\n    else if (sn.type === NodeType.Element) {\n        if (slimDOMOptions.script &&\n            (sn.tagName === 'script' ||\n                (sn.tagName === 'link' &&\n                    sn.attributes.rel === 'preload' &&\n                    sn.attributes.as === 'script'))) {\n            return true;\n        }\n        else if (slimDOMOptions.headFavicon &&\n            ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n                (sn.tagName === 'meta' &&\n                    (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||\n                        lowerIfExists(sn.attributes.name) === 'application-name' ||\n                        lowerIfExists(sn.attributes.rel) === 'icon' ||\n                        lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n                        lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {\n            return true;\n        }\n        else if (sn.tagName === 'meta') {\n            if (slimDOMOptions.headMetaDescKeywords &&\n                lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n                return true;\n            }\n            else if (slimDOMOptions.headMetaSocial &&\n                (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\n                    lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n                    lowerIfExists(sn.attributes.name) === 'pinterest')) {\n                return true;\n            }\n            else if (slimDOMOptions.headMetaRobots &&\n                (lowerIfExists(sn.attributes.name) === 'robots' ||\n                    lowerIfExists(sn.attributes.name) === 'googlebot' ||\n                    lowerIfExists(sn.attributes.name) === 'bingbot')) {\n                return true;\n            }\n            else if (slimDOMOptions.headMetaHttpEquiv &&\n                sn.attributes['http-equiv'] !== undefined) {\n                return true;\n            }\n            else if (slimDOMOptions.headMetaAuthorship &&\n                (lowerIfExists(sn.attributes.name) === 'author' ||\n                    lowerIfExists(sn.attributes.name) === 'generator' ||\n                    lowerIfExists(sn.attributes.name) === 'framework' ||\n                    lowerIfExists(sn.attributes.name) === 'publisher' ||\n                    lowerIfExists(sn.attributes.name) === 'progid' ||\n                    lowerIfExists(sn.attributes.property).match(/^article:/) ||\n                    lowerIfExists(sn.attributes.property).match(/^product:/))) {\n                return true;\n            }\n            else if (slimDOMOptions.headMetaVerification &&\n                (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n                    lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n                    lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n                    lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n                    lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n                    lowerIfExists(sn.attributes.name) === 'verification' ||\n                    lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction serializeNodeWithId(n, options) {\n    var doc = options.doc, map = options.map, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.inlineStylesheet, inlineStylesheet = _b === void 0 ? true : _b, _c = options.maskInputOptions, maskInputOptions = _c === void 0 ? {} : _c, maskTextFn = options.maskTextFn, slimDOMOptions = options.slimDOMOptions, _d = options.recordCanvas, recordCanvas = _d === void 0 ? false : _d, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _e = options.iframeLoadTimeout, iframeLoadTimeout = _e === void 0 ? 5000 : _e;\n    var _f = options.preserveWhiteSpace, preserveWhiteSpace = _f === void 0 ? true : _f;\n    var _serializedNode = serializeNode(n, {\n        doc: doc,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        maskTextClass: maskTextClass,\n        maskTextSelector: maskTextSelector,\n        inlineStylesheet: inlineStylesheet,\n        maskInputOptions: maskInputOptions,\n        maskTextFn: maskTextFn,\n        recordCanvas: recordCanvas,\n    });\n    if (!_serializedNode) {\n        console.warn(n, 'not serialized');\n        return null;\n    }\n    var id;\n    if ('__sn' in n) {\n        id = n.__sn.id;\n    }\n    else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n        (!preserveWhiteSpace &&\n            _serializedNode.type === NodeType.Text &&\n            !_serializedNode.isStyle &&\n            !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)) {\n        id = IGNORED_NODE;\n    }\n    else {\n        id = genId();\n    }\n    var serializedNode = Object.assign(_serializedNode, { id: id });\n    n.__sn = serializedNode;\n    if (id === IGNORED_NODE) {\n        return null;\n    }\n    map[id] = n;\n    if (onSerialize) {\n        onSerialize(n);\n    }\n    var recordChild = !skipChild;\n    if (serializedNode.type === NodeType.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n    }\n    if ((serializedNode.type === NodeType.Document ||\n        serializedNode.type === NodeType.Element) &&\n        recordChild) {\n        if (slimDOMOptions.headWhitespace &&\n            _serializedNode.type === NodeType.Element &&\n            _serializedNode.tagName === 'head') {\n            preserveWhiteSpace = false;\n        }\n        var bypassOptions = {\n            doc: doc,\n            map: map,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            skipChild: skipChild,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            maskTextFn: maskTextFn,\n            slimDOMOptions: slimDOMOptions,\n            recordCanvas: recordCanvas,\n            preserveWhiteSpace: preserveWhiteSpace,\n            onSerialize: onSerialize,\n            onIframeLoad: onIframeLoad,\n            iframeLoadTimeout: iframeLoadTimeout,\n        };\n        for (var _i = 0, _g = Array.from(n.childNodes); _i < _g.length; _i++) {\n            var childN = _g[_i];\n            var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n            if (serializedChildNode) {\n                serializedNode.childNodes.push(serializedChildNode);\n            }\n        }\n        if (isElement(n) && n.shadowRoot) {\n            serializedNode.isShadowHost = true;\n            for (var _h = 0, _j = Array.from(n.shadowRoot.childNodes); _h < _j.length; _h++) {\n                var childN = _j[_h];\n                var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n                if (serializedChildNode) {\n                    serializedChildNode.isShadow = true;\n                    serializedNode.childNodes.push(serializedChildNode);\n                }\n            }\n        }\n    }\n    if (n.parentNode && isShadowRoot(n.parentNode)) {\n        serializedNode.isShadow = true;\n    }\n    if (serializedNode.type === NodeType.Element &&\n        serializedNode.tagName === 'iframe') {\n        onceIframeLoaded(n, function () {\n            var iframeDoc = n.contentDocument;\n            if (iframeDoc && onIframeLoad) {\n                var serializedIframeNode = serializeNodeWithId(iframeDoc, {\n                    doc: iframeDoc,\n                    map: map,\n                    blockClass: blockClass,\n                    blockSelector: blockSelector,\n                    maskTextClass: maskTextClass,\n                    maskTextSelector: maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet: inlineStylesheet,\n                    maskInputOptions: maskInputOptions,\n                    maskTextFn: maskTextFn,\n                    slimDOMOptions: slimDOMOptions,\n                    recordCanvas: recordCanvas,\n                    preserveWhiteSpace: preserveWhiteSpace,\n                    onSerialize: onSerialize,\n                    onIframeLoad: onIframeLoad,\n                    iframeLoadTimeout: iframeLoadTimeout,\n                });\n                if (serializedIframeNode) {\n                    onIframeLoad(n, serializedIframeNode);\n                }\n            }\n        }, iframeLoadTimeout);\n    }\n    return serializedNode;\n}\nfunction snapshot(n, options) {\n    var _a = options || {}, _b = _a.blockClass, blockClass = _b === void 0 ? 'rr-block' : _b, _c = _a.blockSelector, blockSelector = _c === void 0 ? null : _c, _d = _a.maskTextClass, maskTextClass = _d === void 0 ? 'rr-mask' : _d, _e = _a.maskTextSelector, maskTextSelector = _e === void 0 ? null : _e, _f = _a.inlineStylesheet, inlineStylesheet = _f === void 0 ? true : _f, _g = _a.recordCanvas, recordCanvas = _g === void 0 ? false : _g, _h = _a.maskAllInputs, maskAllInputs = _h === void 0 ? false : _h, maskTextFn = _a.maskTextFn, _j = _a.slimDOM, slimDOM = _j === void 0 ? false : _j, preserveWhiteSpace = _a.preserveWhiteSpace, onSerialize = _a.onSerialize, onIframeLoad = _a.onIframeLoad, iframeLoadTimeout = _a.iframeLoadTimeout;\n    var idNodeMap = {};\n    var maskInputOptions = maskAllInputs === true\n        ? {\n            color: true,\n            date: true,\n            'datetime-local': true,\n            email: true,\n            month: true,\n            number: true,\n            range: true,\n            search: true,\n            tel: true,\n            text: true,\n            time: true,\n            url: true,\n            week: true,\n            textarea: true,\n            select: true,\n        }\n        : maskAllInputs === false\n            ? {}\n            : maskAllInputs;\n    var slimDOMOptions = slimDOM === true || slimDOM === 'all'\n        ?\n            {\n                script: true,\n                comment: true,\n                headFavicon: true,\n                headWhitespace: true,\n                headMetaDescKeywords: slimDOM === 'all',\n                headMetaSocial: true,\n                headMetaRobots: true,\n                headMetaHttpEquiv: true,\n                headMetaAuthorship: true,\n                headMetaVerification: true,\n            }\n        : slimDOM === false\n            ? {}\n            : slimDOM;\n    return [\n        serializeNodeWithId(n, {\n            doc: n,\n            map: idNodeMap,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            skipChild: false,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            maskTextFn: maskTextFn,\n            slimDOMOptions: slimDOMOptions,\n            recordCanvas: recordCanvas,\n            preserveWhiteSpace: preserveWhiteSpace,\n            onSerialize: onSerialize,\n            onIframeLoad: onIframeLoad,\n            iframeLoadTimeout: iframeLoadTimeout,\n        }),\n        idNodeMap,\n    ];\n}\nfunction visitSnapshot(node, onVisit) {\n    function walk(current) {\n        onVisit(current);\n        if (current.type === NodeType.Document ||\n            current.type === NodeType.Element) {\n            current.childNodes.forEach(walk);\n        }\n    }\n    walk(node);\n}\nfunction cleanupSnapshot() {\n    _id = 1;\n}\n\nvar commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\nfunction parse(css, options) {\n    if (options === void 0) { options = {}; }\n    var lineno = 1;\n    var column = 1;\n    function updatePosition(str) {\n        var lines = str.match(/\\n/g);\n        if (lines) {\n            lineno += lines.length;\n        }\n        var i = str.lastIndexOf('\\n');\n        column = i === -1 ? column + str.length : str.length - i;\n    }\n    function position() {\n        var start = { line: lineno, column: column };\n        return function (node) {\n            node.position = new Position(start);\n            whitespace();\n            return node;\n        };\n    }\n    var Position = (function () {\n        function Position(start) {\n            this.start = start;\n            this.end = { line: lineno, column: column };\n            this.source = options.source;\n        }\n        return Position;\n    }());\n    Position.prototype.content = css;\n    var errorsList = [];\n    function error(msg) {\n        var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);\n        err.reason = msg;\n        err.filename = options.source;\n        err.line = lineno;\n        err.column = column;\n        err.source = css;\n        if (options.silent) {\n            errorsList.push(err);\n        }\n        else {\n            throw err;\n        }\n    }\n    function stylesheet() {\n        var rulesList = rules();\n        return {\n            type: 'stylesheet',\n            stylesheet: {\n                source: options.source,\n                rules: rulesList,\n                parsingErrors: errorsList,\n            },\n        };\n    }\n    function open() {\n        return match(/^{\\s*/);\n    }\n    function close() {\n        return match(/^}/);\n    }\n    function rules() {\n        var node;\n        var rules = [];\n        whitespace();\n        comments(rules);\n        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n            if (node !== false) {\n                rules.push(node);\n                comments(rules);\n            }\n        }\n        return rules;\n    }\n    function match(re) {\n        var m = re.exec(css);\n        if (!m) {\n            return;\n        }\n        var str = m[0];\n        updatePosition(str);\n        css = css.slice(str.length);\n        return m;\n    }\n    function whitespace() {\n        match(/^\\s*/);\n    }\n    function comments(rules) {\n        if (rules === void 0) { rules = []; }\n        var c;\n        while ((c = comment())) {\n            if (c !== false) {\n                rules.push(c);\n            }\n            c = comment();\n        }\n        return rules;\n    }\n    function comment() {\n        var pos = position();\n        if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n            return;\n        }\n        var i = 2;\n        while ('' !== css.charAt(i) &&\n            ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {\n            ++i;\n        }\n        i += 2;\n        if ('' === css.charAt(i - 1)) {\n            return error('End of comment missing');\n        }\n        var str = css.slice(2, i - 2);\n        column += 2;\n        updatePosition(str);\n        css = css.slice(i);\n        column += 2;\n        return pos({\n            type: 'comment',\n            comment: str,\n        });\n    }\n    function selector() {\n        var m = match(/^([^{]+)/);\n        if (!m) {\n            return;\n        }\n        return trim(m[0])\n            .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n            .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, function (m) {\n            return m.replace(/,/g, '\\u200C');\n        })\n            .split(/\\s*(?![^(]*\\)),\\s*/)\n            .map(function (s) {\n            return s.replace(/\\u200C/g, ',');\n        });\n    }\n    function declaration() {\n        var pos = position();\n        var propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n        if (!propMatch) {\n            return;\n        }\n        var prop = trim(propMatch[0]);\n        if (!match(/^:\\s*/)) {\n            return error(\"property missing ':'\");\n        }\n        var val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n        var ret = pos({\n            type: 'declaration',\n            property: prop.replace(commentre, ''),\n            value: val ? trim(val[0]).replace(commentre, '') : '',\n        });\n        match(/^[;\\s]*/);\n        return ret;\n    }\n    function declarations() {\n        var decls = [];\n        if (!open()) {\n            return error(\"missing '{'\");\n        }\n        comments(decls);\n        var decl;\n        while ((decl = declaration())) {\n            if (decl !== false) {\n                decls.push(decl);\n                comments(decls);\n            }\n            decl = declaration();\n        }\n        if (!close()) {\n            return error(\"missing '}'\");\n        }\n        return decls;\n    }\n    function keyframe() {\n        var m;\n        var vals = [];\n        var pos = position();\n        while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n            vals.push(m[1]);\n            match(/^,\\s*/);\n        }\n        if (!vals.length) {\n            return;\n        }\n        return pos({\n            type: 'keyframe',\n            values: vals,\n            declarations: declarations(),\n        });\n    }\n    function atkeyframes() {\n        var pos = position();\n        var m = match(/^@([-\\w]+)?keyframes\\s*/);\n        if (!m) {\n            return;\n        }\n        var vendor = m[1];\n        m = match(/^([-\\w]+)\\s*/);\n        if (!m) {\n            return error('@keyframes missing name');\n        }\n        var name = m[1];\n        if (!open()) {\n            return error(\"@keyframes missing '{'\");\n        }\n        var frame;\n        var frames = comments();\n        while ((frame = keyframe())) {\n            frames.push(frame);\n            frames = frames.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@keyframes missing '}'\");\n        }\n        return pos({\n            type: 'keyframes',\n            name: name,\n            vendor: vendor,\n            keyframes: frames,\n        });\n    }\n    function atsupports() {\n        var pos = position();\n        var m = match(/^@supports *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var supports = trim(m[1]);\n        if (!open()) {\n            return error(\"@supports missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@supports missing '}'\");\n        }\n        return pos({\n            type: 'supports',\n            supports: supports,\n            rules: style,\n        });\n    }\n    function athost() {\n        var pos = position();\n        var m = match(/^@host\\s*/);\n        if (!m) {\n            return;\n        }\n        if (!open()) {\n            return error(\"@host missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@host missing '}'\");\n        }\n        return pos({\n            type: 'host',\n            rules: style,\n        });\n    }\n    function atmedia() {\n        var pos = position();\n        var m = match(/^@media *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var media = trim(m[1]);\n        if (!open()) {\n            return error(\"@media missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@media missing '}'\");\n        }\n        return pos({\n            type: 'media',\n            media: media,\n            rules: style,\n        });\n    }\n    function atcustommedia() {\n        var pos = position();\n        var m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n        if (!m) {\n            return;\n        }\n        return pos({\n            type: 'custom-media',\n            name: trim(m[1]),\n            media: trim(m[2]),\n        });\n    }\n    function atpage() {\n        var pos = position();\n        var m = match(/^@page */);\n        if (!m) {\n            return;\n        }\n        var sel = selector() || [];\n        if (!open()) {\n            return error(\"@page missing '{'\");\n        }\n        var decls = comments();\n        var decl;\n        while ((decl = declaration())) {\n            decls.push(decl);\n            decls = decls.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@page missing '}'\");\n        }\n        return pos({\n            type: 'page',\n            selectors: sel,\n            declarations: decls,\n        });\n    }\n    function atdocument() {\n        var pos = position();\n        var m = match(/^@([-\\w]+)?document *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var vendor = trim(m[1]);\n        var doc = trim(m[2]);\n        if (!open()) {\n            return error(\"@document missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@document missing '}'\");\n        }\n        return pos({\n            type: 'document',\n            document: doc,\n            vendor: vendor,\n            rules: style,\n        });\n    }\n    function atfontface() {\n        var pos = position();\n        var m = match(/^@font-face\\s*/);\n        if (!m) {\n            return;\n        }\n        if (!open()) {\n            return error(\"@font-face missing '{'\");\n        }\n        var decls = comments();\n        var decl;\n        while ((decl = declaration())) {\n            decls.push(decl);\n            decls = decls.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@font-face missing '}'\");\n        }\n        return pos({\n            type: 'font-face',\n            declarations: decls,\n        });\n    }\n    var atimport = _compileAtrule('import');\n    var atcharset = _compileAtrule('charset');\n    var atnamespace = _compileAtrule('namespace');\n    function _compileAtrule(name) {\n        var re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n        return function () {\n            var pos = position();\n            var m = match(re);\n            if (!m) {\n                return;\n            }\n            var ret = { type: name };\n            ret[name] = m[1].trim();\n            return pos(ret);\n        };\n    }\n    function atrule() {\n        if (css[0] !== '@') {\n            return;\n        }\n        return (atkeyframes() ||\n            atmedia() ||\n            atcustommedia() ||\n            atsupports() ||\n            atimport() ||\n            atcharset() ||\n            atnamespace() ||\n            atdocument() ||\n            atpage() ||\n            athost() ||\n            atfontface());\n    }\n    function rule() {\n        var pos = position();\n        var sel = selector();\n        if (!sel) {\n            return error('selector missing');\n        }\n        comments();\n        return pos({\n            type: 'rule',\n            selectors: sel,\n            declarations: declarations(),\n        });\n    }\n    return addParent(stylesheet());\n}\nfunction trim(str) {\n    return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\nfunction addParent(obj, parent) {\n    var isNode = obj && typeof obj.type === 'string';\n    var childParent = isNode ? obj : parent;\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var k = _a[_i];\n        var value = obj[k];\n        if (Array.isArray(value)) {\n            value.forEach(function (v) {\n                addParent(v, childParent);\n            });\n        }\n        else if (value && typeof value === 'object') {\n            addParent(value, childParent);\n        }\n    }\n    if (isNode) {\n        Object.defineProperty(obj, 'parent', {\n            configurable: true,\n            writable: true,\n            enumerable: false,\n            value: parent || null,\n        });\n    }\n    return obj;\n}\n\nvar tagMap = {\n    script: 'noscript',\n    altglyph: 'altGlyph',\n    altglyphdef: 'altGlyphDef',\n    altglyphitem: 'altGlyphItem',\n    animatecolor: 'animateColor',\n    animatemotion: 'animateMotion',\n    animatetransform: 'animateTransform',\n    clippath: 'clipPath',\n    feblend: 'feBlend',\n    fecolormatrix: 'feColorMatrix',\n    fecomponenttransfer: 'feComponentTransfer',\n    fecomposite: 'feComposite',\n    feconvolvematrix: 'feConvolveMatrix',\n    fediffuselighting: 'feDiffuseLighting',\n    fedisplacementmap: 'feDisplacementMap',\n    fedistantlight: 'feDistantLight',\n    fedropshadow: 'feDropShadow',\n    feflood: 'feFlood',\n    fefunca: 'feFuncA',\n    fefuncb: 'feFuncB',\n    fefuncg: 'feFuncG',\n    fefuncr: 'feFuncR',\n    fegaussianblur: 'feGaussianBlur',\n    feimage: 'feImage',\n    femerge: 'feMerge',\n    femergenode: 'feMergeNode',\n    femorphology: 'feMorphology',\n    feoffset: 'feOffset',\n    fepointlight: 'fePointLight',\n    fespecularlighting: 'feSpecularLighting',\n    fespotlight: 'feSpotLight',\n    fetile: 'feTile',\n    feturbulence: 'feTurbulence',\n    foreignobject: 'foreignObject',\n    glyphref: 'glyphRef',\n    lineargradient: 'linearGradient',\n    radialgradient: 'radialGradient',\n};\nfunction getTagName(n) {\n    var tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n    if (tagName === 'link' && n.attributes._cssText) {\n        tagName = 'style';\n    }\n    return tagName;\n}\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nvar HOVER_SELECTOR = /([^\\\\]):hover/;\nvar HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR, 'g');\nfunction addHoverClass(cssText) {\n    var ast = parse(cssText, {\n        silent: true,\n    });\n    if (!ast.stylesheet) {\n        return cssText;\n    }\n    var selectors = [];\n    ast.stylesheet.rules.forEach(function (rule) {\n        if ('selectors' in rule) {\n            (rule.selectors || []).forEach(function (selector) {\n                if (HOVER_SELECTOR.test(selector)) {\n                    selectors.push(selector);\n                }\n            });\n        }\n    });\n    if (selectors.length === 0)\n        return cssText;\n    var selectorMatcher = new RegExp(selectors\n        .filter(function (selector, index) { return selectors.indexOf(selector) === index; })\n        .sort(function (a, b) { return b.length - a.length; })\n        .map(function (selector) {\n        return escapeRegExp(selector);\n    })\n        .join('|'), 'g');\n    return cssText.replace(selectorMatcher, function (selector) {\n        var newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\n        return selector + \", \" + newSelector;\n    });\n}\nfunction buildNode(n, options) {\n    var doc = options.doc, hackCss = options.hackCss;\n    switch (n.type) {\n        case NodeType.Document:\n            return doc.implementation.createDocument(null, '', null);\n        case NodeType.DocumentType:\n            return doc.implementation.createDocumentType(n.name || 'html', n.publicId, n.systemId);\n        case NodeType.Element:\n            var tagName = getTagName(n);\n            var node_1;\n            if (n.isSVG) {\n                node_1 = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n            }\n            else {\n                node_1 = doc.createElement(tagName);\n            }\n            var _loop_1 = function (name) {\n                if (!n.attributes.hasOwnProperty(name)) {\n                    return \"continue\";\n                }\n                var value = n.attributes[name];\n                value =\n                    typeof value === 'boolean' || typeof value === 'number' ? '' : value;\n                if (!name.startsWith('rr_')) {\n                    var isTextarea = tagName === 'textarea' && name === 'value';\n                    var isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';\n                    if (isRemoteOrDynamicCss && hackCss) {\n                        value = addHoverClass(value);\n                    }\n                    if (isTextarea || isRemoteOrDynamicCss) {\n                        var child = doc.createTextNode(value);\n                        for (var _i = 0, _a = Array.from(node_1.childNodes); _i < _a.length; _i++) {\n                            var c = _a[_i];\n                            if (c.nodeType === node_1.TEXT_NODE) {\n                                node_1.removeChild(c);\n                            }\n                        }\n                        node_1.appendChild(child);\n                        return \"continue\";\n                    }\n                    if (tagName === 'iframe' && name === 'src') {\n                        return \"continue\";\n                    }\n                    try {\n                        if (n.isSVG && name === 'xlink:href') {\n                            node_1.setAttributeNS('http://www.w3.org/1999/xlink', name, value);\n                        }\n                        else if (name === 'onload' ||\n                            name === 'onclick' ||\n                            name.substring(0, 7) === 'onmouse') {\n                            node_1.setAttribute('_' + name, value);\n                        }\n                        else {\n                            node_1.setAttribute(name, value);\n                        }\n                    }\n                    catch (error) {\n                    }\n                }\n                else {\n                    if (tagName === 'canvas' && name === 'rr_dataURL') {\n                        var image_1 = document.createElement('img');\n                        image_1.src = value;\n                        image_1.onload = function () {\n                            var ctx = node_1.getContext('2d');\n                            if (ctx) {\n                                ctx.drawImage(image_1, 0, 0, image_1.width, image_1.height);\n                            }\n                        };\n                    }\n                    if (name === 'rr_width') {\n                        node_1.style.width = value;\n                    }\n                    if (name === 'rr_height') {\n                        node_1.style.height = value;\n                    }\n                    if (name === 'rr_mediaState') {\n                        switch (value) {\n                            case 'played':\n                                node_1.play();\n                            case 'paused':\n                                node_1.pause();\n                                break;\n                            default:\n                        }\n                    }\n                }\n            };\n            for (var name in n.attributes) {\n                _loop_1(name);\n            }\n            if (n.isShadowHost) {\n                if (!node_1.shadowRoot) {\n                    node_1.attachShadow({ mode: 'open' });\n                }\n                else {\n                    while (node_1.shadowRoot.firstChild) {\n                        node_1.shadowRoot.removeChild(node_1.shadowRoot.firstChild);\n                    }\n                }\n            }\n            return node_1;\n        case NodeType.Text:\n            return doc.createTextNode(n.isStyle && hackCss ? addHoverClass(n.textContent) : n.textContent);\n        case NodeType.CDATA:\n            return doc.createCDATASection(n.textContent);\n        case NodeType.Comment:\n            return doc.createComment(n.textContent);\n        default:\n            return null;\n    }\n}\nfunction buildNodeWithSN(n, options) {\n    var doc = options.doc, map = options.map, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.hackCss, hackCss = _b === void 0 ? true : _b, afterAppend = options.afterAppend;\n    var node = buildNode(n, { doc: doc, hackCss: hackCss });\n    if (!node) {\n        return null;\n    }\n    if (n.rootId) {\n        console.assert(map[n.rootId] === doc, 'Target document should has the same root id.');\n    }\n    if (n.type === NodeType.Document) {\n        doc.close();\n        doc.open();\n        node = doc;\n    }\n    node.__sn = n;\n    map[n.id] = node;\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\n        !skipChild) {\n        for (var _i = 0, _c = n.childNodes; _i < _c.length; _i++) {\n            var childN = _c[_i];\n            var childNode = buildNodeWithSN(childN, {\n                doc: doc,\n                map: map,\n                skipChild: false,\n                hackCss: hackCss,\n                afterAppend: afterAppend,\n            });\n            if (!childNode) {\n                console.warn('Failed to rebuild', childN);\n                continue;\n            }\n            if (childN.isShadow && isElement(node) && node.shadowRoot) {\n                node.shadowRoot.appendChild(childNode);\n            }\n            else {\n                node.appendChild(childNode);\n            }\n            if (afterAppend) {\n                afterAppend(childNode);\n            }\n        }\n    }\n    return node;\n}\nfunction visit(idNodeMap, onVisit) {\n    function walk(node) {\n        onVisit(node);\n    }\n    for (var key in idNodeMap) {\n        if (idNodeMap[key]) {\n            walk(idNodeMap[key]);\n        }\n    }\n}\nfunction handleScroll(node) {\n    var n = node.__sn;\n    if (n.type !== NodeType.Element) {\n        return;\n    }\n    var el = node;\n    for (var name in n.attributes) {\n        if (!(n.attributes.hasOwnProperty(name) && name.startsWith('rr_'))) {\n            continue;\n        }\n        var value = n.attributes[name];\n        if (name === 'rr_scrollLeft') {\n            el.scrollLeft = value;\n        }\n        if (name === 'rr_scrollTop') {\n            el.scrollTop = value;\n        }\n    }\n}\nfunction rebuild(n, options) {\n    var doc = options.doc, onVisit = options.onVisit, _a = options.hackCss, hackCss = _a === void 0 ? true : _a, afterAppend = options.afterAppend;\n    var idNodeMap = {};\n    var node = buildNodeWithSN(n, {\n        doc: doc,\n        map: idNodeMap,\n        skipChild: false,\n        hackCss: hackCss,\n        afterAppend: afterAppend,\n    });\n    visit(idNodeMap, function (visitedNode) {\n        if (onVisit) {\n            onVisit(visitedNode);\n        }\n        handleScroll(visitedNode);\n    });\n    return [node, idNodeMap];\n}\n\nexport { snapshot, serializeNodeWithId, rebuild, buildNodeWithSN, addHoverClass, transformAttribute, visitSnapshot, cleanupSnapshot, needMaskingText, IGNORED_NODE, NodeType, isElement, isShadowRoot };\n","//      \n// An event handler can take an optional event argument\n// and should not return a value\n                                          \n                                                               \n\n// An array of all currently registered event handlers for a type\n                                            \n                                                            \n// A map of event types and their corresponding event handlers.\n                        \n                                 \n                                   \n  \n\n/** Mitt: Tiny (~200b) functional event emitter / pubsub.\n *  @name mitt\n *  @returns {Mitt}\n */\nfunction mitt(all                 ) {\n\tall = all || Object.create(null);\n\n\treturn {\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to listen for, or `\"*\"` for all events\n\t\t * @param  {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton: function on(type        , handler              ) {\n\t\t\t(all[type] || (all[type] = [])).push(handler);\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to unregister `handler` from, or `\"*\"`\n\t\t * @param  {Function} handler Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff: function off(type        , handler              ) {\n\t\t\tif (all[type]) {\n\t\t\t\tall[type].splice(all[type].indexOf(handler) >>> 0, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `\"*\"` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * @param {String} type  The event type to invoke\n\t\t * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit: function emit(type        , evt     ) {\n\t\t\t(all[type] || []).slice().map(function (handler) { handler(evt); });\n\t\t\t(all['*'] || []).slice().map(function (handler) { handler(type, evt); });\n\t\t}\n\t};\n}\n\nexport default mitt;\n//# sourceMappingURL=mitt.es.js.map\n","import {\n  serializedNodeWithId,\n  idNodeMap,\n  INode,\n  MaskInputOptions,\n  SlimDOMOptions,\n} from 'rrweb-snapshot';\nimport { PackFn, UnpackFn } from './packer/base';\nimport { FontFaceDescriptors } from 'css-font-loading-module';\nimport { IframeManager } from './record/iframe-manager';\nimport { ShadowDomManager } from './record/shadow-dom-manager';\n\nexport enum EventType {\n  DomContentLoaded,\n  Load,\n  FullSnapshot,\n  IncrementalSnapshot,\n  Meta,\n  Custom,\n}\n\nexport type domContentLoadedEvent = {\n  type: EventType.DomContentLoaded;\n  data: {};\n};\n\nexport type loadedEvent = {\n  type: EventType.Load;\n  data: {};\n};\n\nexport type fullSnapshotEvent = {\n  type: EventType.FullSnapshot;\n  data: {\n    node: serializedNodeWithId;\n    initialOffset: {\n      top: number;\n      left: number;\n    };\n  };\n};\n\nexport type incrementalSnapshotEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type metaEvent = {\n  type: EventType.Meta;\n  data: {\n    href: string;\n    width: number;\n    height: number;\n  };\n};\n\nexport type logEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type customEvent<T = unknown> = {\n  type: EventType.Custom;\n  data: {\n    tag: string;\n    payload: T;\n  };\n};\n\nexport type styleSheetEvent = {};\n\nexport enum IncrementalSource {\n  Mutation,\n  MouseMove,\n  MouseInteraction,\n  Scroll,\n  ViewportResize,\n  Input,\n  TouchMove,\n  MediaInteraction,\n  StyleSheetRule,\n  CanvasMutation,\n  Font,\n  Log,\n  Drag,\n}\n\nexport type mutationData = {\n  source: IncrementalSource.Mutation;\n} & mutationCallbackParam;\n\nexport type mousemoveData = {\n  source:\n    | IncrementalSource.MouseMove\n    | IncrementalSource.TouchMove\n    | IncrementalSource.Drag;\n  positions: mousePosition[];\n};\n\nexport type mouseInteractionData = {\n  source: IncrementalSource.MouseInteraction;\n} & mouseInteractionParam;\n\nexport type scrollData = {\n  source: IncrementalSource.Scroll;\n} & scrollPosition;\n\nexport type viewportResizeData = {\n  source: IncrementalSource.ViewportResize;\n} & viewportResizeDimension;\n\nexport type inputData = {\n  source: IncrementalSource.Input;\n  id: number;\n} & inputValue;\n\nexport type mediaInteractionData = {\n  source: IncrementalSource.MediaInteraction;\n} & mediaInteractionParam;\n\nexport type styleSheetRuleData = {\n  source: IncrementalSource.StyleSheetRule;\n} & styleSheetRuleParam;\n\nexport type canvasMutationData = {\n  source: IncrementalSource.CanvasMutation;\n} & canvasMutationParam;\n\nexport type fontData = {\n  source: IncrementalSource.Font;\n} & fontParam;\n\nexport type logData = {\n  source: IncrementalSource.Log;\n} & LogParam;\n\nexport type incrementalData =\n  | mutationData\n  | mousemoveData\n  | mouseInteractionData\n  | scrollData\n  | viewportResizeData\n  | inputData\n  | mediaInteractionData\n  | styleSheetRuleData\n  | canvasMutationData\n  | fontData\n  | logData;\n\nexport type event =\n  | domContentLoadedEvent\n  | loadedEvent\n  | fullSnapshotEvent\n  | incrementalSnapshotEvent\n  | metaEvent\n  | logEvent\n  | customEvent;\n\nexport type eventWithTime = event & {\n  timestamp: number;\n  delay?: number;\n};\n\nexport type blockClass = string | RegExp;\n\nexport type maskTextClass = string | RegExp;\n\nexport type SamplingStrategy = Partial<{\n  /**\n   * false means not to record mouse/touch move events\n   * number is the throttle threshold of recording mouse/touch move\n   */\n  mousemove: boolean | number;\n  /**\n   * number is the throttle threshold of mouse/touch move callback\n   */\n  mousemoveCallback: number;\n  /**\n   * false means not to record mouse interaction events\n   * can also specify record some kinds of mouse interactions\n   */\n  mouseInteraction: boolean | Record<string, boolean | undefined>;\n  /**\n   * number is the throttle threshold of recording scroll\n   */\n  scroll: number;\n  /**\n   * 'all' will record all the input events\n   * 'last' will only record the last input value while input a sequence of chars\n   */\n  input: 'all' | 'last';\n}>;\n\nexport type recordOptions<T> = {\n  emit?: (e: T, isCheckout?: boolean) => void;\n  checkoutEveryNth?: number;\n  checkoutEveryNms?: number;\n  blockClass?: blockClass;\n  blockSelector?: string;\n  ignoreClass?: string;\n  maskTextClass?: maskTextClass;\n  maskTextSelector?: string;\n  maskAllInputs?: boolean;\n  maskInputOptions?: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  slimDOMOptions?: SlimDOMOptions | 'all' | true;\n  inlineStylesheet?: boolean;\n  hooks?: hooksParam;\n  packFn?: PackFn;\n  sampling?: SamplingStrategy;\n  recordCanvas?: boolean;\n  collectFonts?: boolean;\n  // departed, please use sampling options\n  mousemoveWait?: number;\n  recordLog?: boolean | LogRecordOptions;\n};\n\nexport type observerParam = {\n  mutationCb: mutationCallBack;\n  mousemoveCb: mousemoveCallBack;\n  mouseInteractionCb: mouseInteractionCallBack;\n  scrollCb: scrollCallback;\n  viewportResizeCb: viewportResizeCallback;\n  inputCb: inputCallback;\n  mediaInteractionCb: mediaInteractionCallback;\n  blockClass: blockClass;\n  blockSelector: string | null;\n  ignoreClass: string;\n  maskTextClass: maskTextClass;\n  maskTextSelector: string | null;\n  maskInputOptions: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  inlineStylesheet: boolean;\n  styleSheetRuleCb: styleSheetRuleCallback;\n  canvasMutationCb: canvasMutationCallback;\n  fontCb: fontCallback;\n  logCb: logCallback;\n  logOptions: LogRecordOptions;\n  sampling: SamplingStrategy;\n  recordCanvas: boolean;\n  collectFonts: boolean;\n  slimDOMOptions: SlimDOMOptions;\n  doc: Document;\n  iframeManager: IframeManager;\n  shadowDomManager: ShadowDomManager;\n};\n\nexport type hooksParam = {\n  mutation?: mutationCallBack;\n  mousemove?: mousemoveCallBack;\n  mouseInteraction?: mouseInteractionCallBack;\n  scroll?: scrollCallback;\n  viewportResize?: viewportResizeCallback;\n  input?: inputCallback;\n  mediaInteaction?: mediaInteractionCallback;\n  styleSheetRule?: styleSheetRuleCallback;\n  canvasMutation?: canvasMutationCallback;\n  font?: fontCallback;\n  log?: logCallback;\n};\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\nexport type mutationRecord = {\n  type: string;\n  target: Node;\n  oldValue: string | null;\n  addedNodes: NodeList;\n  removedNodes: NodeList;\n  attributeName: string | null;\n};\n\nexport type textCursor = {\n  node: Node;\n  value: string | null;\n};\nexport type textMutation = {\n  id: number;\n  value: string | null;\n};\n\nexport type attributeCursor = {\n  node: Node;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\nexport type attributeMutation = {\n  id: number;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\n\nexport type removedNodeMutation = {\n  parentId: number;\n  id: number;\n  isShadow?: boolean;\n};\n\nexport type addedNodeMutation = {\n  parentId: number;\n  // Newly recorded mutations will not have previousId any more, just for compatibility\n  previousId?: number | null;\n  nextId: number | null;\n  node: serializedNodeWithId;\n};\n\nexport type mutationCallbackParam = {\n  texts: textMutation[];\n  attributes: attributeMutation[];\n  removes: removedNodeMutation[];\n  adds: addedNodeMutation[];\n  isAttachIframe?: true;\n};\n\nexport type mutationCallBack = (m: mutationCallbackParam) => void;\n\nexport type mousemoveCallBack = (\n  p: mousePosition[],\n  source:\n    | IncrementalSource.MouseMove\n    | IncrementalSource.TouchMove\n    | IncrementalSource.Drag,\n) => void;\n\nexport type mousePosition = {\n  x: number;\n  y: number;\n  id: number;\n  timeOffset: number;\n};\n\nexport enum MouseInteractions {\n  MouseUp,\n  MouseDown,\n  Click,\n  ContextMenu,\n  DblClick,\n  Focus,\n  Blur,\n  TouchStart,\n  TouchMove_Departed, // we will start a separate observer for touch move event\n  TouchEnd,\n}\n\ntype mouseInteractionParam = {\n  type: MouseInteractions;\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type mouseInteractionCallBack = (d: mouseInteractionParam) => void;\n\nexport type scrollPosition = {\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type scrollCallback = (p: scrollPosition) => void;\n\nexport type styleSheetAddRule = {\n  rule: string;\n  index?: number;\n};\n\nexport type styleSheetDeleteRule = {\n  index: number;\n};\n\nexport type styleSheetRuleParam = {\n  id: number;\n  removes?: styleSheetDeleteRule[];\n  adds?: styleSheetAddRule[];\n};\n\nexport type styleSheetRuleCallback = (s: styleSheetRuleParam) => void;\n\nexport type canvasMutationCallback = (p: canvasMutationParam) => void;\n\nexport type canvasMutationParam = {\n  id: number;\n  property: string;\n  args: Array<unknown>;\n  setter?: true;\n};\n\nexport type fontParam = {\n  family: string;\n  fontSource: string;\n  buffer: boolean;\n  descriptors?: FontFaceDescriptors;\n};\n\nexport type LogLevel =\n  | 'assert'\n  | 'clear'\n  | 'count'\n  | 'countReset'\n  | 'debug'\n  | 'dir'\n  | 'dirxml'\n  | 'error'\n  | 'group'\n  | 'groupCollapsed'\n  | 'groupEnd'\n  | 'info'\n  | 'log'\n  | 'table'\n  | 'time'\n  | 'timeEnd'\n  | 'timeLog'\n  | 'trace'\n  | 'warn';\n\n/* fork from interface Console */\n// all kinds of console functions\nexport type Logger = {\n  assert?: typeof console.assert;\n  clear?: typeof console.clear;\n  count?: typeof console.count;\n  countReset?: typeof console.countReset;\n  debug?: typeof console.debug;\n  dir?: typeof console.dir;\n  dirxml?: typeof console.dirxml;\n  error?: typeof console.error;\n  group?: typeof console.group;\n  groupCollapsed?: typeof console.groupCollapsed;\n  groupEnd?: () => void;\n  info?: typeof console.info;\n  log?: typeof console.log;\n  table?: typeof console.table;\n  time?: typeof console.time;\n  timeEnd?: typeof console.timeEnd;\n  timeLog?: typeof console.timeLog;\n  trace?: typeof console.trace;\n  warn?: typeof console.warn;\n};\n\n/**\n * define an interface to replay log records\n * (data: logData) => void> function to display the log data\n */\nexport type ReplayLogger = Partial<Record<LogLevel, (data: logData) => void>>;\n\nexport type LogParam = {\n  level: LogLevel;\n  trace: string[];\n  payload: string[];\n};\n\nexport type fontCallback = (p: fontParam) => void;\n\nexport type logCallback = (p: LogParam) => void;\n\nexport type viewportResizeDimension = {\n  width: number;\n  height: number;\n};\n\nexport type viewportResizeCallback = (d: viewportResizeDimension) => void;\n\nexport type inputValue = {\n  text: string;\n  isChecked: boolean;\n};\n\nexport type inputCallback = (v: inputValue & { id: number }) => void;\n\nexport const enum MediaInteractions {\n  Play,\n  Pause,\n}\n\nexport type mediaInteractionParam = {\n  type: MediaInteractions;\n  id: number;\n};\n\nexport type mediaInteractionCallback = (p: mediaInteractionParam) => void;\n\nexport type DocumentDimension = {\n  x: number;\n  y: number;\n  // scale value relative to its parent iframe\n  relativeScale: number;\n  // scale value relative to the root iframe\n  absoluteScale: number;\n};\n\nexport type Mirror = {\n  map: idNodeMap;\n  getId: (n: INode) => number;\n  getNode: (id: number) => INode | null;\n  removeNodeFromMap: (n: INode) => void;\n  has: (id: number) => boolean;\n  reset: () => void;\n};\n\nexport type throttleOptions = {\n  leading?: boolean;\n  trailing?: boolean;\n};\n\nexport type listenerHandler = () => void;\nexport type hookResetter = () => void;\n\nexport type playerConfig = {\n  speed: number;\n  maxSpeed: number;\n  root: Element;\n  loadTimeout: number;\n  skipInactive: boolean;\n  showWarning: boolean;\n  showDebug: boolean;\n  blockClass: string;\n  liveMode: boolean;\n  insertStyleRules: string[];\n  triggerFocus: boolean;\n  UNSAFE_replayCanvas: boolean;\n  pauseAnimation?: boolean;\n  mouseTail:\n    | boolean\n    | {\n        duration?: number;\n        lineCap?: string;\n        lineWidth?: number;\n        strokeStyle?: string;\n      };\n  unpackFn?: UnpackFn;\n  logConfig: LogReplayConfig;\n};\n\nexport type LogReplayConfig = {\n  level?: LogLevel[] | undefined;\n  replayLogger: ReplayLogger | undefined;\n};\n\nexport type playerMetaData = {\n  startTime: number;\n  endTime: number;\n  totalTime: number;\n};\n\nexport type missingNode = {\n  node: Node;\n  mutation: addedNodeMutation;\n};\nexport type missingNodeMap = {\n  [id: number]: missingNode;\n};\n\nexport type actionWithDelay = {\n  doAction: () => void;\n  delay: number;\n};\n\nexport type Handler = (event?: unknown) => void;\n\nexport type Emitter = {\n  on(type: string, handler: Handler): void;\n  emit(type: string, event?: unknown): void;\n  off(type: string, handler: Handler): void;\n};\n\nexport type Arguments<T> = T extends (...payload: infer U) => unknown\n  ? U\n  : unknown;\n\nexport enum ReplayerEvents {\n  Start = 'start',\n  Pause = 'pause',\n  Resume = 'resume',\n  Resize = 'resize',\n  Finish = 'finish',\n  FullsnapshotRebuilded = 'fullsnapshot-rebuilded',\n  LoadStylesheetStart = 'load-stylesheet-start',\n  LoadStylesheetEnd = 'load-stylesheet-end',\n  SkipStart = 'skip-start',\n  SkipEnd = 'skip-end',\n  MouseInteraction = 'mouse-interaction',\n  EventCast = 'event-cast',\n  CustomEvent = 'custom-event',\n  Flush = 'flush',\n  StateChange = 'state-change',\n  PlayBack = 'play-back',\n}\n\nexport type MaskInputFn = (text: string) => string;\n\nexport type MaskTextFn = (text: string) => string;\n\n// store the state that would be changed during the process(unmount from dom and mount again)\nexport type ElementState = {\n  // [scrollLeft,scrollTop]\n  scroll?: [number, number];\n};\n\nexport type StringifyOptions = {\n  // limit of string length\n  stringLengthLimit?: number;\n  /**\n   * limit of number of keys in an object\n   * if an object contains more keys than this limit, we would call its toString function directly\n   */\n  numOfKeysLimit: number;\n};\n\nexport type LogRecordOptions = {\n  level?: LogLevel[] | undefined;\n  lengthThreshold?: number;\n  stringifyOptions?: StringifyOptions;\n  logger?: Logger;\n};\n","/**\n * A fork version of https://github.com/iamdustan/smoothscroll\n * Add support of customize target window and document\n */\n\n// @ts-nocheck\n// tslint:disable\nexport function polyfill(w: Window = window, d = document) {\n  // return if scroll behavior is supported and polyfill is not forced\n  if (\n    'scrollBehavior' in d.documentElement.style &&\n    w.__forceSmoothScrollPolyfill__ !== true\n  ) {\n    return;\n  }\n\n  // globals\n  var Element = w.HTMLElement || w.Element;\n  var SCROLL_TIME = 468;\n\n  // object gathering original scroll methods\n  var original = {\n    scroll: w.scroll || w.scrollTo,\n    scrollBy: w.scrollBy,\n    elementScroll: Element.prototype.scroll || scrollElement,\n    scrollIntoView: Element.prototype.scrollIntoView,\n  };\n\n  // define timing method\n  var now =\n    w.performance && w.performance.now\n      ? w.performance.now.bind(w.performance)\n      : Date.now;\n\n  /**\n   * indicates if a the current browser is made by Microsoft\n   * @method isMicrosoftBrowser\n   * @param {String} userAgent\n   * @returns {Boolean}\n   */\n  function isMicrosoftBrowser(userAgent) {\n    var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n    return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n  }\n\n  /*\n   * IE has rounding bug rounding down clientHeight and clientWidth and\n   * rounding up scrollHeight and scrollWidth causing false positives\n   * on hasScrollableSpace\n   */\n  var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n  /**\n   * changes scroll position inside an element\n   * @method scrollElement\n   * @param {Number} x\n   * @param {Number} y\n   * @returns {undefined}\n   */\n  function scrollElement(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n  }\n\n  /**\n   * returns result of applying ease math function to a number\n   * @method ease\n   * @param {Number} k\n   * @returns {Number}\n   */\n  function ease(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n\n  /**\n   * indicates if a smooth behavior should be applied\n   * @method shouldBailOut\n   * @param {Number|Object} firstArg\n   * @returns {Boolean}\n   */\n  function shouldBailOut(firstArg) {\n    if (\n      firstArg === null ||\n      typeof firstArg !== 'object' ||\n      firstArg.behavior === undefined ||\n      firstArg.behavior === 'auto' ||\n      firstArg.behavior === 'instant'\n    ) {\n      // first argument is not an object/null\n      // or behavior is auto, instant or undefined\n      return true;\n    }\n\n    if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n      // first argument is an object and behavior is smooth\n      return false;\n    }\n\n    // throw error when behavior is not supported\n    throw new TypeError(\n      'behavior member of ScrollOptions ' +\n        firstArg.behavior +\n        ' is not a valid value for enumeration ScrollBehavior.',\n    );\n  }\n\n  /**\n   * indicates if an element has scrollable space in the provided axis\n   * @method hasScrollableSpace\n   * @param {Node} el\n   * @param {String} axis\n   * @returns {Boolean}\n   */\n  function hasScrollableSpace(el, axis) {\n    if (axis === 'Y') {\n      return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n    }\n\n    if (axis === 'X') {\n      return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n    }\n  }\n\n  /**\n   * indicates if an element has a scrollable overflow property in the axis\n   * @method canOverflow\n   * @param {Node} el\n   * @param {String} axis\n   * @returns {Boolean}\n   */\n  function canOverflow(el, axis) {\n    var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n    return overflowValue === 'auto' || overflowValue === 'scroll';\n  }\n\n  /**\n   * indicates if an element can be scrolled in either axis\n   * @method isScrollable\n   * @param {Node} el\n   * @param {String} axis\n   * @returns {Boolean}\n   */\n  function isScrollable(el) {\n    var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n    var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n    return isScrollableY || isScrollableX;\n  }\n\n  /**\n   * finds scrollable parent of an element\n   * @method findScrollableParent\n   * @param {Node} el\n   * @returns {Node} el\n   */\n  function findScrollableParent(el) {\n    while (el !== d.body && isScrollable(el) === false) {\n      el = el.parentNode || el.host;\n    }\n\n    return el;\n  }\n\n  /**\n   * self invoked function that, given a context, steps through scrolling\n   * @method step\n   * @param {Object} context\n   * @returns {undefined}\n   */\n  function step(context) {\n    var time = now();\n    var value;\n    var currentX;\n    var currentY;\n    var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n    // avoid elapsed times higher than one\n    elapsed = elapsed > 1 ? 1 : elapsed;\n\n    // apply easing to elapsed time\n    value = ease(elapsed);\n\n    currentX = context.startX + (context.x - context.startX) * value;\n    currentY = context.startY + (context.y - context.startY) * value;\n\n    context.method.call(context.scrollable, currentX, currentY);\n\n    // scroll more if we have not reached our destination\n    if (currentX !== context.x || currentY !== context.y) {\n      w.requestAnimationFrame(step.bind(w, context));\n    }\n  }\n\n  /**\n   * scrolls window or element with a smooth behavior\n   * @method smoothScroll\n   * @param {Object|Node} el\n   * @param {Number} x\n   * @param {Number} y\n   * @returns {undefined}\n   */\n  function smoothScroll(el, x, y) {\n    var scrollable;\n    var startX;\n    var startY;\n    var method;\n    var startTime = now();\n\n    // define scroll context\n    if (el === d.body) {\n      scrollable = w;\n      startX = w.scrollX || w.pageXOffset;\n      startY = w.scrollY || w.pageYOffset;\n      method = original.scroll;\n    } else {\n      scrollable = el;\n      startX = el.scrollLeft;\n      startY = el.scrollTop;\n      method = scrollElement;\n    }\n\n    // scroll looping over a frame\n    step({\n      scrollable: scrollable,\n      method: method,\n      startTime: startTime,\n      startX: startX,\n      startY: startY,\n      x: x,\n      y: y,\n    });\n  }\n\n  // ORIGINAL METHODS OVERRIDES\n  // w.scroll and w.scrollTo\n  w.scroll = w.scrollTo = function () {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scroll.call(\n        w,\n        arguments[0].left !== undefined\n          ? arguments[0].left\n          : typeof arguments[0] !== 'object'\n          ? arguments[0]\n          : w.scrollX || w.pageXOffset,\n        // use top prop, second argument if present or fallback to scrollY\n        arguments[0].top !== undefined\n          ? arguments[0].top\n          : arguments[1] !== undefined\n          ? arguments[1]\n          : w.scrollY || w.pageYOffset,\n      );\n\n      return;\n    }\n\n    // LET THE SMOOTHNESS BEGIN!\n    smoothScroll.call(\n      w,\n      d.body,\n      arguments[0].left !== undefined\n        ? ~~arguments[0].left\n        : w.scrollX || w.pageXOffset,\n      arguments[0].top !== undefined\n        ? ~~arguments[0].top\n        : w.scrollY || w.pageYOffset,\n    );\n  };\n\n  // w.scrollBy\n  w.scrollBy = function () {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0])) {\n      original.scrollBy.call(\n        w,\n        arguments[0].left !== undefined\n          ? arguments[0].left\n          : typeof arguments[0] !== 'object'\n          ? arguments[0]\n          : 0,\n        arguments[0].top !== undefined\n          ? arguments[0].top\n          : arguments[1] !== undefined\n          ? arguments[1]\n          : 0,\n      );\n\n      return;\n    }\n\n    // LET THE SMOOTHNESS BEGIN!\n    smoothScroll.call(\n      w,\n      d.body,\n      ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n      ~~arguments[0].top + (w.scrollY || w.pageYOffset),\n    );\n  };\n\n  // Element.prototype.scroll and Element.prototype.scrollTo\n  Element.prototype.scroll = Element.prototype.scrollTo = function () {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      // if one number is passed, throw error to match Firefox implementation\n      if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n        throw new SyntaxError('Value could not be converted');\n      }\n\n      original.elementScroll.call(\n        this,\n        // use left prop, first number argument or fallback to scrollLeft\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : typeof arguments[0] !== 'object'\n          ? ~~arguments[0]\n          : this.scrollLeft,\n        // use top prop, second argument or fallback to scrollTop\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : arguments[1] !== undefined\n          ? ~~arguments[1]\n          : this.scrollTop,\n      );\n\n      return;\n    }\n\n    var left = arguments[0].left;\n    var top = arguments[0].top;\n\n    // LET THE SMOOTHNESS BEGIN!\n    smoothScroll.call(\n      this,\n      this,\n      typeof left === 'undefined' ? this.scrollLeft : ~~left,\n      typeof top === 'undefined' ? this.scrollTop : ~~top,\n    );\n  };\n\n  // Element.prototype.scrollBy\n  Element.prototype.scrollBy = function () {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      original.elementScroll.call(\n        this,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left + this.scrollLeft\n          : ~~arguments[0] + this.scrollLeft,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top + this.scrollTop\n          : ~~arguments[1] + this.scrollTop,\n      );\n\n      return;\n    }\n\n    this.scroll({\n      left: ~~arguments[0].left + this.scrollLeft,\n      top: ~~arguments[0].top + this.scrollTop,\n      behavior: arguments[0].behavior,\n    });\n  };\n\n  // Element.prototype.scrollIntoView\n  Element.prototype.scrollIntoView = function () {\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scrollIntoView.call(\n        this,\n        arguments[0] === undefined ? true : arguments[0],\n      );\n\n      return;\n    }\n\n    // LET THE SMOOTHNESS BEGIN!\n    var scrollableParent = findScrollableParent(this);\n    var parentRects = scrollableParent.getBoundingClientRect();\n    var clientRects = this.getBoundingClientRect();\n\n    if (scrollableParent !== d.body) {\n      // reveal element inside parent\n      smoothScroll.call(\n        this,\n        scrollableParent,\n        scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n        scrollableParent.scrollTop + clientRects.top - parentRects.top,\n      );\n\n      // reveal parent in viewport unless is fixed\n      if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n        w.scrollBy({\n          left: parentRects.left,\n          top: parentRects.top,\n          behavior: 'smooth',\n        });\n      }\n    } else {\n      // reveal element in viewport\n      w.scrollBy({\n        left: clientRects.left,\n        top: clientRects.top,\n        behavior: 'smooth',\n      });\n    }\n  };\n}\n","import {\n  actionWithDelay,\n  eventWithTime,\n  EventType,\n  IncrementalSource,\n} from '../types';\n\nexport class Timer {\n  public timeOffset: number = 0;\n  public speed: number;\n\n  private actions: actionWithDelay[];\n  private raf: number | null = null;\n  private liveMode: boolean;\n\n  constructor(actions: actionWithDelay[] = [], speed: number) {\n    this.actions = actions;\n    this.speed = speed;\n  }\n  /**\n   * Add an action after the timer starts.\n   * @param action\n   */\n  public addAction(action: actionWithDelay) {\n    const index = this.findActionIndex(action);\n    this.actions.splice(index, 0, action);\n  }\n  /**\n   * Add all actions before the timer starts\n   * @param actions\n   */\n  public addActions(actions: actionWithDelay[]) {\n    this.actions = this.actions.concat(actions);\n  }\n\n  public start() {\n    this.timeOffset = 0;\n    let lastTimestamp = performance.now();\n    const { actions } = this;\n    const self = this;\n    function check() {\n      const time = performance.now();\n      self.timeOffset += (time - lastTimestamp) * self.speed;\n      lastTimestamp = time;\n      while (actions.length) {\n        const action = actions[0];\n        if (self.timeOffset >= action.delay) {\n          actions.shift();\n          action.doAction();\n        } else {\n          break;\n        }\n      }\n      if (actions.length > 0 || self.liveMode) {\n        self.raf = requestAnimationFrame(check);\n      }\n    }\n    this.raf = requestAnimationFrame(check);\n  }\n\n  public clear() {\n    if (this.raf) {\n      cancelAnimationFrame(this.raf);\n      this.raf = null;\n    }\n    this.actions.length = 0;\n  }\n\n  public setSpeed(speed: number) {\n    this.speed = speed;\n  }\n\n  public toggleLiveMode(mode: boolean) {\n    this.liveMode = mode;\n  }\n\n  public isActive() {\n    return this.raf !== null;\n  }\n\n  private findActionIndex(action: actionWithDelay): number {\n    let start = 0;\n    let end = this.actions.length - 1;\n    while (start <= end) {\n      let mid = Math.floor((start + end) / 2);\n      if (this.actions[mid].delay < action.delay) {\n        start = mid + 1;\n      } else if (this.actions[mid].delay > action.delay) {\n        end = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return start;\n  }\n}\n\n// TODO: add speed to mouse move timestamp calculation\nexport function addDelay(event: eventWithTime, baselineTime: number): number {\n  // Mouse move events was recorded in a throttle function,\n  // so we need to find the real timestamp by traverse the time offsets.\n  if (\n    event.type === EventType.IncrementalSnapshot &&\n    event.data.source === IncrementalSource.MouseMove\n  ) {\n    const firstOffset = event.data.positions[0].timeOffset;\n    // timeOffset is a negative offset to event.timestamp\n    const firstTimestamp = event.timestamp + firstOffset;\n    event.delay = firstTimestamp - baselineTime;\n    return firstTimestamp - baselineTime;\n  }\n  event.delay = event.timestamp - baselineTime;\n  return event.delay;\n}\n","/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar t;!function(t){t[t.NotStarted=0]=\"NotStarted\",t[t.Running=1]=\"Running\",t[t.Stopped=2]=\"Stopped\"}(t||(t={}));var n={type:\"xstate.init\"};function e(t){return void 0===t?[]:[].concat(t)}function r(t){return{type:\"xstate.assign\",assignment:t}}function i(t,n){return\"string\"==typeof(t=\"string\"==typeof t&&n&&n[t]?n[t]:t)?{type:t}:\"function\"==typeof t?{type:t.name,exec:t}:t}function o(t){return function(n){return t===n}}function a(t){return\"string\"==typeof t?{type:t}:t}function u(t,n){return{value:t,context:n,actions:[],changed:!1,matches:o(t)}}function c(t,n){void 0===n&&(n={});var r={config:t,_options:n,initialState:{value:t.initial,actions:e(t.states[t.initial].entry).map((function(t){return i(t,n.actions)})),context:t.context,matches:o(t.initial)},transition:function(n,c){var s,f,v=\"string\"==typeof n?{value:n,context:t.context}:n,l=v.value,p=v.context,g=a(c),y=t.states[l];if(y.on){var d=e(y.on[g.type]),x=function(n){if(void 0===n)return{value:u(l,p)};var e=\"string\"==typeof n?{target:n}:n,a=e.target,c=void 0===a?l:a,s=e.actions,f=void 0===s?[]:s,v=e.cond,d=p;if((void 0===v?function(){return!0}:v)(p,g)){var x=t.states[c],m=!1,h=[].concat(y.exit,f,x.entry).filter((function(t){return t})).map((function(t){return i(t,r._options.actions)})).filter((function(t){if(\"xstate.assign\"===t.type){m=!0;var n=Object.assign({},d);return\"function\"==typeof t.assignment?n=t.assignment(d,g):Object.keys(t.assignment).forEach((function(e){n[e]=\"function\"==typeof t.assignment[e]?t.assignment[e](d,g):t.assignment[e]})),d=n,!1}return!0}));return{value:{value:c,context:d,actions:h,changed:c!==l||h.length>0||m,matches:o(c)}}}};try{for(var m=function(t){var n=\"function\"==typeof Symbol&&t[Symbol.iterator],e=0;return n?n.call(t):{next:function(){return t&&e>=t.length&&(t=void 0),{value:t&&t[e++],done:!t}}}}(d),h=m.next();!h.done;h=m.next()){var S=x(h.value);if(\"object\"==typeof S)return S.value}}catch(t){s={error:t}}finally{try{h&&!h.done&&(f=m.return)&&f.call(m)}finally{if(s)throw s.error}}}return u(l,p)}};return r}var s=function(t,n){return t.actions.forEach((function(e){var r=e.exec;return r&&r(t.context,n)}))};function f(e){var r=e.initialState,i=t.NotStarted,u=new Set,c={_machine:e,send:function(n){i===t.Running&&(r=e.transition(r,n),s(r,a(n)),u.forEach((function(t){return t(r)})))},subscribe:function(t){return u.add(t),t(r),{unsubscribe:function(){return u.delete(t)}}},start:function(a){if(a){var u=\"object\"==typeof a?a:{context:e.config.context,value:a};r={value:u.value,actions:[],context:u.context,matches:o(u.value)}}return i=t.Running,s(r,n),c},stop:function(){return i=t.Stopped,u.clear(),c},get state(){return r},get status(){return i}};return c}export{t as InterpreterStatus,r as assign,c as createMachine,f as interpret};\n","import {\n  Mirror,\n  throttleOptions,\n  listenerHandler,\n  hookResetter,\n  blockClass,\n  eventWithTime,\n  EventType,\n  IncrementalSource,\n  addedNodeMutation,\n  removedNodeMutation,\n  textMutation,\n  attributeMutation,\n  mutationData,\n  scrollData,\n  inputData,\n  DocumentDimension,\n} from './types';\nimport {\n  INode,\n  IGNORED_NODE,\n  serializedNodeWithId,\n  NodeType,\n  isShadowRoot,\n} from 'rrweb-snapshot';\n\nexport function on(\n  type: string,\n  fn: EventListenerOrEventListenerObject,\n  target: Document | Window = document,\n): listenerHandler {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\n\nexport const mirror: Mirror = {\n  map: {},\n  getId(n) {\n    // if n is not a serialized INode, use -1 as its id.\n    if (!n.__sn) {\n      return -1;\n    }\n    return n.__sn.id;\n  },\n  getNode(id) {\n    return mirror.map[id] || null;\n  },\n  // TODO: use a weakmap to get rid of manually memory management\n  removeNodeFromMap(n) {\n    const id = n.__sn && n.__sn.id;\n    delete mirror.map[id];\n    if (n.childNodes) {\n      n.childNodes.forEach((child) =>\n        mirror.removeNodeFromMap((child as Node) as INode),\n      );\n    }\n  },\n  has(id) {\n    return mirror.map.hasOwnProperty(id);\n  },\n  reset() {\n    mirror.map = {};\n  },\n};\n\n// copy from underscore and modified\nexport function throttle<T>(\n  func: (arg: T) => void,\n  wait: number,\n  options: throttleOptions = {},\n) {\n  let timeout: number | null = null;\n  let previous = 0;\n  // tslint:disable-next-line: only-arrow-functions\n  return function (arg: T) {\n    let now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    let remaining = wait - (now - previous);\n    let context = this;\n    let args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        window.clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = window.setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nexport function hookSetter<T>(\n  target: T,\n  key: string | number | symbol,\n  d: PropertyDescriptor,\n  isRevoked?: boolean,\n  win = window,\n): hookResetter {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked\n      ? d\n      : {\n          set(value) {\n            // put hooked setter into event loop to avoid of set latency\n            setTimeout(() => {\n              d.set!.call(this, value);\n            }, 0);\n            if (original && original.set) {\n              original.set.call(this, value);\n            }\n          },\n        },\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\n\n// copy from https://github.com/getsentry/sentry-javascript/blob/b2109071975af8bf0316d3b5b38f519bdaf5dc15/packages/utils/src/object.ts\nexport function patch(\n  // tslint:disable-next-line:no-any\n  source: { [key: string]: any },\n  name: string,\n  // tslint:disable-next-line:no-any\n  replacement: (...args: any[]) => any,\n): () => void {\n  try {\n    if (!(name in source)) {\n      return () => {};\n    }\n\n    const original = source[name] as () => unknown;\n    const wrapped = replacement(original);\n\n    // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n    // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n    // tslint:disable-next-line:strict-type-predicates\n    if (typeof wrapped === 'function') {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original,\n        },\n      });\n    }\n\n    source[name] = wrapped;\n\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {};\n    // This can throw if multiple fill happens on a global object like XMLHttpRequest\n    // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n  }\n}\n\nexport function getWindowHeight(): number {\n  return (\n    window.innerHeight ||\n    (document.documentElement && document.documentElement.clientHeight) ||\n    (document.body && document.body.clientHeight)\n  );\n}\n\nexport function getWindowWidth(): number {\n  return (\n    window.innerWidth ||\n    (document.documentElement && document.documentElement.clientWidth) ||\n    (document.body && document.body.clientWidth)\n  );\n}\n\nexport function isBlocked(node: Node | null, blockClass: blockClass): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    let needBlock = false;\n    if (typeof blockClass === 'string') {\n      needBlock = (node as HTMLElement).classList.contains(blockClass);\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (blockClass.test(className)) {\n          needBlock = true;\n        }\n      });\n    }\n    return needBlock || isBlocked(node.parentNode, blockClass);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return isBlocked(node.parentNode, blockClass);\n  }\n  return isBlocked(node.parentNode, blockClass);\n}\n\nexport function isIgnored(n: Node | INode): boolean {\n  if ('__sn' in n) {\n    return (n as INode).__sn.id === IGNORED_NODE;\n  }\n  // The main part of the slimDOM check happens in\n  // rrweb-snapshot::serializeNodeWithId\n  return false;\n}\n\nexport function isAncestorRemoved(target: INode): boolean {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror.getId(target);\n  if (!mirror.has(id)) {\n    return true;\n  }\n  if (\n    target.parentNode &&\n    target.parentNode.nodeType === target.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n  // if the root is not document, it means the node is not in the DOM tree anymore\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved((target.parentNode as unknown) as INode);\n}\n\nexport function isTouchEvent(\n  event: MouseEvent | TouchEvent,\n): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches);\n}\n\nexport function polyfill(win = window) {\n  if ('NodeList' in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as NodeList['forEach'];\n  }\n\n  if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as DOMTokenList['forEach'];\n  }\n\n  // https://github.com/Financial-Times/polyfill-service/pull/183\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = function contains(node) {\n      if (!(0 in arguments)) {\n        throw new TypeError('1 argument is required');\n      }\n\n      do {\n        if (this === node) {\n          return true;\n        }\n        // tslint:disable-next-line: no-conditional-assignment\n      } while ((node = node && node.parentNode));\n\n      return false;\n    };\n  }\n}\n\nexport function needCastInSyncMode(event: eventWithTime): boolean {\n  switch (event.type) {\n    case EventType.DomContentLoaded:\n    case EventType.Load:\n    case EventType.Custom:\n      return false;\n    case EventType.FullSnapshot:\n    case EventType.Meta:\n      return true;\n    default:\n      break;\n  }\n\n  switch (event.data.source) {\n    case IncrementalSource.MouseMove:\n    case IncrementalSource.MouseInteraction:\n    case IncrementalSource.TouchMove:\n    case IncrementalSource.MediaInteraction:\n      return false;\n    case IncrementalSource.ViewportResize:\n    case IncrementalSource.StyleSheetRule:\n    case IncrementalSource.Scroll:\n    case IncrementalSource.Input:\n      return true;\n    default:\n      break;\n  }\n\n  return true;\n}\n\nexport type TreeNode = {\n  id: number;\n  mutation: addedNodeMutation;\n  parent?: TreeNode;\n  children: Record<number, TreeNode>;\n  texts: textMutation[];\n  attributes: attributeMutation[];\n};\nexport class TreeIndex {\n  public tree!: Record<number, TreeNode>;\n\n  private removeNodeMutations!: removedNodeMutation[];\n  private textMutations!: textMutation[];\n  private attributeMutations!: attributeMutation[];\n  private indexes!: Map<number, TreeNode>;\n  private removeIdSet!: Set<number>;\n  private scrollMap!: Map<number, scrollData>;\n  private inputMap!: Map<number, inputData>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public add(mutation: addedNodeMutation) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode: TreeNode = {\n      id: mutation.node.id,\n      mutation,\n      children: [],\n      texts: [],\n      attributes: [],\n    };\n    if (!parentTreeNode) {\n      this.tree[treeNode.id] = treeNode;\n    } else {\n      treeNode.parent = parentTreeNode;\n      parentTreeNode.children[treeNode.id] = treeNode;\n    }\n    this.indexes.set(treeNode.id, treeNode);\n  }\n\n  public remove(mutation: removedNodeMutation) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode = this.indexes.get(mutation.id);\n\n    const deepRemoveFromMirror = (id: number) => {\n      this.removeIdSet.add(id);\n      const node = mirror.getNode(id);\n      node?.childNodes.forEach((childNode) => {\n        if ('__sn' in childNode) {\n          deepRemoveFromMirror(((childNode as unknown) as INode).__sn.id);\n        }\n      });\n    };\n    const deepRemoveFromTreeIndex = (node: TreeNode) => {\n      this.removeIdSet.add(node.id);\n      Object.values(node.children).forEach((n) => deepRemoveFromTreeIndex(n));\n      const _treeNode = this.indexes.get(node.id);\n      if (_treeNode) {\n        const _parentTreeNode = _treeNode.parent;\n        if (_parentTreeNode) {\n          delete _treeNode.parent;\n          delete _parentTreeNode.children[_treeNode.id];\n          this.indexes.delete(mutation.id);\n        }\n      }\n    };\n\n    if (!treeNode) {\n      this.removeNodeMutations.push(mutation);\n      deepRemoveFromMirror(mutation.id);\n    } else if (!parentTreeNode) {\n      delete this.tree[treeNode.id];\n      this.indexes.delete(treeNode.id);\n      deepRemoveFromTreeIndex(treeNode);\n    } else {\n      delete treeNode.parent;\n      delete parentTreeNode.children[treeNode.id];\n      this.indexes.delete(mutation.id);\n      deepRemoveFromTreeIndex(treeNode);\n    }\n  }\n\n  public text(mutation: textMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.texts.push(mutation);\n    } else {\n      this.textMutations.push(mutation);\n    }\n  }\n\n  public attribute(mutation: attributeMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.attributes.push(mutation);\n    } else {\n      this.attributeMutations.push(mutation);\n    }\n  }\n\n  public scroll(d: scrollData) {\n    this.scrollMap.set(d.id, d);\n  }\n\n  public input(d: inputData) {\n    this.inputMap.set(d.id, d);\n  }\n\n  public flush(): {\n    mutationData: mutationData;\n    scrollMap: TreeIndex['scrollMap'];\n    inputMap: TreeIndex['inputMap'];\n  } {\n    const {\n      tree,\n      removeNodeMutations,\n      textMutations,\n      attributeMutations,\n    } = this;\n\n    const batchMutationData: mutationData = {\n      source: IncrementalSource.Mutation,\n      removes: removeNodeMutations,\n      texts: textMutations,\n      attributes: attributeMutations,\n      adds: [],\n    };\n\n    const walk = (treeNode: TreeNode, removed: boolean) => {\n      if (removed) {\n        this.removeIdSet.add(treeNode.id);\n      }\n      batchMutationData.texts = batchMutationData.texts\n        .concat(removed ? [] : treeNode.texts)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      batchMutationData.attributes = batchMutationData.attributes\n        .concat(removed ? [] : treeNode.attributes)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      if (\n        !this.removeIdSet.has(treeNode.id) &&\n        !this.removeIdSet.has(treeNode.mutation.parentId) &&\n        !removed\n      ) {\n        batchMutationData.adds.push(treeNode.mutation);\n        if (treeNode.children) {\n          Object.values(treeNode.children).forEach((n) => walk(n, false));\n        }\n      } else {\n        Object.values(treeNode.children).forEach((n) => walk(n, true));\n      }\n    };\n\n    Object.values(tree).forEach((n) => walk(n, false));\n\n    for (const id of this.scrollMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.scrollMap.delete(id);\n      }\n    }\n    for (const id of this.inputMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.inputMap.delete(id);\n      }\n    }\n\n    const scrollMap = new Map(this.scrollMap);\n    const inputMap = new Map(this.inputMap);\n\n    this.reset();\n\n    return {\n      mutationData: batchMutationData,\n      scrollMap,\n      inputMap,\n    };\n  }\n\n  private reset() {\n    this.tree = [];\n    this.indexes = new Map();\n    this.removeNodeMutations = [];\n    this.textMutations = [];\n    this.attributeMutations = [];\n    this.removeIdSet = new Set();\n    this.scrollMap = new Map();\n    this.inputMap = new Map();\n  }\n}\n\ntype ResolveTree = {\n  value: addedNodeMutation;\n  children: ResolveTree[];\n  parent: ResolveTree | null;\n};\n\nexport function queueToResolveTrees(queue: addedNodeMutation[]): ResolveTree[] {\n  const queueNodeMap: Record<number, ResolveTree> = {};\n  const putIntoMap = (\n    m: addedNodeMutation,\n    parent: ResolveTree | null,\n  ): ResolveTree => {\n    const nodeInTree: ResolveTree = {\n      value: m,\n      parent,\n      children: [],\n    };\n    queueNodeMap[m.node.id] = nodeInTree;\n    return nodeInTree;\n  };\n\n  const queueNodeTrees: ResolveTree[] = [];\n  for (const mutation of queue) {\n    const { nextId, parentId } = mutation;\n    if (nextId && nextId in queueNodeMap) {\n      const nextInTree = queueNodeMap[nextId];\n      if (nextInTree.parent) {\n        const idx = nextInTree.parent.children.indexOf(nextInTree);\n        nextInTree.parent.children.splice(\n          idx,\n          0,\n          putIntoMap(mutation, nextInTree.parent),\n        );\n      } else {\n        const idx = queueNodeTrees.indexOf(nextInTree);\n        queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\n      }\n      continue;\n    }\n    if (parentId in queueNodeMap) {\n      const parentInTree = queueNodeMap[parentId];\n      parentInTree.children.push(putIntoMap(mutation, parentInTree));\n      continue;\n    }\n    queueNodeTrees.push(putIntoMap(mutation, null));\n  }\n\n  return queueNodeTrees;\n}\n\nexport function iterateResolveTree(\n  tree: ResolveTree,\n  cb: (mutation: addedNodeMutation) => unknown,\n) {\n  cb(tree.value);\n  /**\n   * The resolve tree was designed to reflect the DOM layout,\n   * but we need append next sibling first, so we do a reverse\n   * loop here.\n   */\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    iterateResolveTree(tree.children[i], cb);\n  }\n}\n\ntype HTMLIFrameINode = HTMLIFrameElement & {\n  __sn: serializedNodeWithId;\n};\nexport type AppendedIframe = {\n  mutationInQueue: addedNodeMutation;\n  builtNode: HTMLIFrameINode;\n};\n\nexport function isIframeINode(\n  node: INode | ShadowRoot,\n): node is HTMLIFrameINode {\n  if ('__sn' in node) {\n    return (\n      node.__sn.type === NodeType.Element && node.__sn.tagName === 'iframe'\n    );\n  }\n  // node can be document fragment when using the virtual parent feature\n  return false;\n}\n\nexport function getBaseDimension(\n  node: Node,\n  rootIframe: Node,\n): DocumentDimension {\n  const frameElement = node.ownerDocument?.defaultView?.frameElement;\n  if (!frameElement || frameElement === rootIframe) {\n    return {\n      x: 0,\n      y: 0,\n      relativeScale: 1,\n      absoluteScale: 1,\n    };\n  }\n\n  const frameDimension = frameElement.getBoundingClientRect();\n  const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\n  // the iframe element may have a scale transform\n  const relativeScale = frameDimension.height / frameElement.clientHeight;\n  return {\n    x:\n      frameDimension.x * frameBaseDimension.relativeScale +\n      frameBaseDimension.x,\n    y:\n      frameDimension.y * frameBaseDimension.relativeScale +\n      frameBaseDimension.y,\n    relativeScale,\n    absoluteScale: frameBaseDimension.absoluteScale * relativeScale,\n  };\n}\n\nexport function hasShadowRoot<T extends Node>(\n  n: T,\n): n is T & { shadowRoot: ShadowRoot } {\n  return Boolean(((n as unknown) as Element)?.shadowRoot);\n}\n","import { createMachine, interpret, assign, StateMachine } from '@xstate/fsm';\nimport {\n  playerConfig,\n  eventWithTime,\n  actionWithDelay,\n  ReplayerEvents,\n  EventType,\n  Emitter,\n  IncrementalSource,\n} from '../types';\nimport { Timer, addDelay } from './timer';\nimport { needCastInSyncMode } from '../utils';\n\nexport type PlayerContext = {\n  events: eventWithTime[];\n  timer: Timer;\n  timeOffset: number;\n  baselineTime: number;\n  lastPlayedEvent: eventWithTime | null;\n};\nexport type PlayerEvent =\n  | {\n      type: 'PLAY';\n      payload: {\n        timeOffset: number;\n      };\n    }\n  | {\n      type: 'CAST_EVENT';\n      payload: {\n        event: eventWithTime;\n      };\n    }\n  | { type: 'PAUSE' }\n  | { type: 'TO_LIVE'; payload: { baselineTime?: number } }\n  | {\n      type: 'ADD_EVENT';\n      payload: {\n        event: eventWithTime;\n      };\n    }\n  | {\n      type: 'END';\n    };\nexport type PlayerState =\n  | {\n      value: 'playing';\n      context: PlayerContext;\n    }\n  | {\n      value: 'paused';\n      context: PlayerContext;\n    }\n  | {\n      value: 'live';\n      context: PlayerContext;\n    };\n\n/**\n * If the array have multiple meta and fullsnapshot events,\n * return the events from last meta to the end.\n */\nexport function discardPriorSnapshots(\n  events: eventWithTime[],\n  baselineTime: number,\n): eventWithTime[] {\n  for (let idx = events.length - 1; idx >= 0; idx--) {\n    const event = events[idx];\n    if (event.type === EventType.Meta) {\n      if (event.timestamp <= baselineTime) {\n        return events.slice(idx);\n      }\n    }\n  }\n  return events;\n}\n\ntype PlayerAssets = {\n  emitter: Emitter;\n  getCastFn(event: eventWithTime, isSync: boolean): () => void;\n};\nexport function createPlayerService(\n  context: PlayerContext,\n  { getCastFn, emitter }: PlayerAssets,\n) {\n  const playerMachine = createMachine<PlayerContext, PlayerEvent, PlayerState>(\n    {\n      id: 'player',\n      context,\n      initial: 'paused',\n      states: {\n        playing: {\n          on: {\n            PAUSE: {\n              target: 'paused',\n              actions: ['pause'],\n            },\n            CAST_EVENT: {\n              target: 'playing',\n              actions: 'castEvent',\n            },\n            END: {\n              target: 'paused',\n              actions: ['resetLastPlayedEvent', 'pause'],\n            },\n            ADD_EVENT: {\n              target: 'playing',\n              actions: ['addEvent'],\n            },\n          },\n        },\n        paused: {\n          on: {\n            PLAY: {\n              target: 'playing',\n              actions: ['recordTimeOffset', 'play'],\n            },\n            CAST_EVENT: {\n              target: 'paused',\n              actions: 'castEvent',\n            },\n            TO_LIVE: {\n              target: 'live',\n              actions: ['startLive'],\n            },\n            ADD_EVENT: {\n              target: 'paused',\n              actions: ['addEvent'],\n            },\n          },\n        },\n        live: {\n          on: {\n            ADD_EVENT: {\n              target: 'live',\n              actions: ['addEvent'],\n            },\n            CAST_EVENT: {\n              target: 'live',\n              actions: ['castEvent'],\n            },\n          },\n        },\n      },\n    },\n    {\n      actions: {\n        castEvent: assign({\n          lastPlayedEvent: (ctx, event) => {\n            if (event.type === 'CAST_EVENT') {\n              return event.payload.event;\n            }\n            return ctx.lastPlayedEvent;\n          },\n        }),\n        recordTimeOffset: assign((ctx, event) => {\n          let timeOffset = ctx.timeOffset;\n          if ('payload' in event && 'timeOffset' in event.payload) {\n            timeOffset = event.payload.timeOffset;\n          }\n          return {\n            ...ctx,\n            timeOffset,\n            baselineTime: ctx.events[0].timestamp + timeOffset,\n          };\n        }),\n        play(ctx) {\n          const { timer, events, baselineTime, lastPlayedEvent } = ctx;\n          timer.clear();\n          for (const event of events) {\n            // TODO: improve this API\n            addDelay(event, baselineTime);\n          }\n          const neededEvents = discardPriorSnapshots(events, baselineTime);\n\n          let lastPlayedTimestamp = lastPlayedEvent?.timestamp;\n          if (\n            lastPlayedEvent?.type === EventType.IncrementalSnapshot &&\n            lastPlayedEvent.data.source === IncrementalSource.MouseMove\n          ) {\n            lastPlayedTimestamp =\n              lastPlayedEvent.timestamp +\n              lastPlayedEvent.data.positions[0]?.timeOffset;\n          }\n          if (baselineTime < (lastPlayedTimestamp || 0)) {\n            emitter.emit(ReplayerEvents.PlayBack);\n          }\n\n          const actions = new Array<actionWithDelay>();\n          for (const event of neededEvents) {\n            if (\n              lastPlayedTimestamp &&\n              lastPlayedTimestamp < baselineTime &&\n              (event.timestamp <= lastPlayedTimestamp ||\n                event === lastPlayedEvent)\n            ) {\n              continue;\n            }\n            const isSync = event.timestamp < baselineTime;\n            if (isSync && !needCastInSyncMode(event)) {\n              continue;\n            }\n            const castFn = getCastFn(event, isSync);\n            if (isSync) {\n              castFn();\n            } else {\n              actions.push({\n                doAction: () => {\n                  castFn();\n                  emitter.emit(ReplayerEvents.EventCast, event);\n                },\n                delay: event.delay!,\n              });\n            }\n          }\n          emitter.emit(ReplayerEvents.Flush);\n          timer.addActions(actions);\n          timer.start();\n        },\n        pause(ctx) {\n          ctx.timer.clear();\n        },\n        resetLastPlayedEvent: assign((ctx) => {\n          return {\n            ...ctx,\n            lastPlayedEvent: null,\n          };\n        }),\n        startLive: assign({\n          baselineTime: (ctx, event) => {\n            ctx.timer.toggleLiveMode(true);\n            ctx.timer.start();\n            if (event.type === 'TO_LIVE' && event.payload.baselineTime) {\n              return event.payload.baselineTime;\n            }\n            return Date.now();\n          },\n        }),\n        addEvent: assign((ctx, machineEvent) => {\n          const { baselineTime, timer, events } = ctx;\n          if (machineEvent.type === 'ADD_EVENT') {\n            const { event } = machineEvent.payload;\n            addDelay(event, baselineTime);\n\n            let end = events.length - 1;\n            if (!events[end] || events[end].timestamp <= event.timestamp) {\n              // fast track\n              events.push(event);\n            } else {\n              let insertionIndex = -1;\n              let start = 0;\n              while (start <= end) {\n                let mid = Math.floor((start + end) / 2);\n                if (events[mid].timestamp <= event.timestamp) {\n                  start = mid + 1;\n                } else {\n                  end = mid - 1;\n                }\n              }\n              if (insertionIndex === -1) {\n                insertionIndex = start;\n              }\n              events.splice(insertionIndex, 0, event);\n            }\n\n            const isSync = event.timestamp < baselineTime;\n            const castFn = getCastFn(event, isSync);\n            if (isSync) {\n              castFn();\n            } else if (timer.isActive()) {\n              timer.addAction({\n                doAction: () => {\n                  castFn();\n                  emitter.emit(ReplayerEvents.EventCast, event);\n                },\n                delay: event.delay!,\n              });\n            }\n          }\n          return { ...ctx, events };\n        }),\n      },\n    },\n  );\n  return interpret(playerMachine);\n}\n\nexport type SpeedContext = {\n  normalSpeed: playerConfig['speed'];\n  timer: Timer;\n};\n\nexport type SpeedEvent =\n  | {\n      type: 'FAST_FORWARD';\n      payload: { speed: playerConfig['speed'] };\n    }\n  | {\n      type: 'BACK_TO_NORMAL';\n    }\n  | {\n      type: 'SET_SPEED';\n      payload: { speed: playerConfig['speed'] };\n    };\n\nexport type SpeedState =\n  | {\n      value: 'normal';\n      context: SpeedContext;\n    }\n  | {\n      value: 'skipping';\n      context: SpeedContext;\n    };\n\nexport function createSpeedService(context: SpeedContext) {\n  const speedMachine = createMachine<SpeedContext, SpeedEvent, SpeedState>(\n    {\n      id: 'speed',\n      context,\n      initial: 'normal',\n      states: {\n        normal: {\n          on: {\n            FAST_FORWARD: {\n              target: 'skipping',\n              actions: ['recordSpeed', 'setSpeed'],\n            },\n            SET_SPEED: {\n              target: 'normal',\n              actions: ['setSpeed'],\n            },\n          },\n        },\n        skipping: {\n          on: {\n            BACK_TO_NORMAL: {\n              target: 'normal',\n              actions: ['restoreSpeed'],\n            },\n            SET_SPEED: {\n              target: 'normal',\n              actions: ['setSpeed'],\n            },\n          },\n        },\n      },\n    },\n    {\n      actions: {\n        setSpeed: (ctx, event) => {\n          if ('payload' in event) {\n            ctx.timer.setSpeed(event.payload.speed);\n          }\n        },\n        recordSpeed: assign({\n          normalSpeed: (ctx) => ctx.timer.speed,\n        }),\n        restoreSpeed: (ctx) => {\n          ctx.timer.setSpeed(ctx.normalSpeed);\n        },\n      },\n    },\n  );\n\n  return interpret(speedMachine);\n}\n\nexport type PlayerMachineState = StateMachine.State<\n  PlayerContext,\n  PlayerEvent,\n  PlayerState\n>;\n\nexport type SpeedMachineState = StateMachine.State<\n  SpeedContext,\n  SpeedEvent,\n  SpeedState\n>;\n","const rules: (blockClass: string) => string[] = (blockClass: string) => [\n  `.${blockClass} { background: #ccc }`,\n  'noscript { display: none !important; }',\n];\n\nexport default rules;\n","import { rebuild, buildNodeWithSN, INode, NodeType } from 'rrweb-snapshot';\nimport * as mittProxy from 'mitt';\nimport { polyfill as smoothscrollPolyfill } from './smoothscroll';\nimport { Timer } from './timer';\nimport { createPlayerService, createSpeedService } from './machine';\nimport {\n  EventType,\n  IncrementalSource,\n  fullSnapshotEvent,\n  eventWithTime,\n  MouseInteractions,\n  playerConfig,\n  playerMetaData,\n  viewportResizeDimension,\n  missingNodeMap,\n  addedNodeMutation,\n  missingNode,\n  incrementalSnapshotEvent,\n  incrementalData,\n  ReplayerEvents,\n  Handler,\n  Emitter,\n  MediaInteractions,\n  metaEvent,\n  mutationData,\n  scrollData,\n  inputData,\n  canvasMutationData,\n  ElementState,\n  LogReplayConfig,\n  logData,\n  ReplayLogger,\n} from '../types';\nimport {\n  mirror,\n  polyfill,\n  TreeIndex,\n  queueToResolveTrees,\n  iterateResolveTree,\n  AppendedIframe,\n  isIframeINode,\n  getBaseDimension,\n  hasShadowRoot,\n} from '../utils';\nimport getInjectStyleRules from './styles/inject-style';\nimport './styles/style.css';\n\nconst SKIP_TIME_THRESHOLD = 10 * 1000;\nconst SKIP_TIME_INTERVAL = 5 * 1000;\n\n// https://github.com/rollup/rollup/issues/1267#issuecomment-296395734\n// tslint:disable-next-line\nconst mitt = (mittProxy as any).default || mittProxy;\n\nconst REPLAY_CONSOLE_PREFIX = '[replayer]';\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\n\ntype PatchedConsoleLog = {\n  [ORIGINAL_ATTRIBUTE_NAME]: typeof console.log;\n};\n\nconst defaultMouseTailConfig = {\n  duration: 500,\n  lineCap: 'round',\n  lineWidth: 3,\n  strokeStyle: 'red',\n} as const;\n\nconst defaultLogConfig: LogReplayConfig = {\n  level: [\n    'assert',\n    'clear',\n    'count',\n    'countReset',\n    'debug',\n    'dir',\n    'dirxml',\n    'error',\n    'group',\n    'groupCollapsed',\n    'groupEnd',\n    'info',\n    'log',\n    'table',\n    'time',\n    'timeEnd',\n    'timeLog',\n    'trace',\n    'warn',\n  ],\n  replayLogger: undefined,\n};\n\nexport class Replayer {\n  public wrapper: HTMLDivElement;\n  public iframe: HTMLIFrameElement;\n\n  public service: ReturnType<typeof createPlayerService>;\n  public speedService: ReturnType<typeof createSpeedService>;\n  public get timer() {\n    return this.service.state.context.timer;\n  }\n\n  public config: playerConfig;\n\n  private mouse: HTMLDivElement;\n  private mouseTail: HTMLCanvasElement | null = null;\n  private tailPositions: Array<{ x: number; y: number }> = [];\n\n  private emitter: Emitter = mitt();\n\n  private nextUserInteractionEvent: eventWithTime | null;\n\n  // tslint:disable-next-line: variable-name\n  private legacy_missingNodeRetryMap: missingNodeMap = {};\n\n  private treeIndex!: TreeIndex;\n  private fragmentParentMap!: Map<INode, INode>;\n  private elementStateMap!: Map<INode, ElementState>;\n\n  private imageMap: Map<eventWithTime, HTMLImageElement> = new Map();\n\n  /** The first time the player is playing. */\n  private firstPlayedEvent: eventWithTime | null = null;\n\n  private newDocumentQueue: addedNodeMutation[] = [];\n\n  constructor(\n    events: Array<eventWithTime | string>,\n    config?: Partial<playerConfig>,\n  ) {\n    if (!config?.liveMode && events.length < 2) {\n      throw new Error('Replayer need at least 2 events.');\n    }\n    const defaultConfig: playerConfig = {\n      speed: 1,\n      maxSpeed: 360,\n      root: document.body,\n      loadTimeout: 0,\n      skipInactive: false,\n      showWarning: true,\n      showDebug: false,\n      blockClass: 'rr-block',\n      liveMode: false,\n      insertStyleRules: [],\n      triggerFocus: true,\n      UNSAFE_replayCanvas: false,\n      pauseAnimation: true,\n      mouseTail: defaultMouseTailConfig,\n      logConfig: defaultLogConfig,\n    };\n    this.config = Object.assign({}, defaultConfig, config);\n    if (!this.config.logConfig.replayLogger) {\n      this.config.logConfig.replayLogger = this.getConsoleLogger();\n    }\n\n    this.handleResize = this.handleResize.bind(this);\n    this.getCastFn = this.getCastFn.bind(this);\n    this.emitter.on(ReplayerEvents.Resize, this.handleResize as Handler);\n\n    this.setupDom();\n\n    this.treeIndex = new TreeIndex();\n    this.fragmentParentMap = new Map<INode, INode>();\n    this.elementStateMap = new Map<INode, ElementState>();\n    this.emitter.on(ReplayerEvents.Flush, () => {\n      const { scrollMap, inputMap } = this.treeIndex.flush();\n\n      this.fragmentParentMap.forEach((parent, frag) =>\n        this.restoreRealParent(frag, parent),\n      );\n      this.fragmentParentMap.clear();\n      this.elementStateMap.clear();\n\n      for (const d of scrollMap.values()) {\n        this.applyScroll(d);\n      }\n      for (const d of inputMap.values()) {\n        this.applyInput(d);\n      }\n    });\n    this.emitter.on(ReplayerEvents.PlayBack, () => {\n      this.firstPlayedEvent = null;\n      mirror.reset();\n    });\n\n    const timer = new Timer([], config?.speed || defaultConfig.speed);\n    this.service = createPlayerService(\n      {\n        events: events\n          .map((e) => {\n            if (config && config.unpackFn) {\n              return config.unpackFn(e as string);\n            }\n            return e as eventWithTime;\n          })\n          .sort((a1, a2) => a1.timestamp - a2.timestamp),\n        timer,\n        timeOffset: 0,\n        baselineTime: 0,\n        lastPlayedEvent: null,\n      },\n      {\n        getCastFn: this.getCastFn,\n        emitter: this.emitter,\n      },\n    );\n    this.service.start();\n    this.service.subscribe((state) => {\n      this.emitter.emit(ReplayerEvents.StateChange, {\n        player: state,\n      });\n    });\n    this.speedService = createSpeedService({\n      normalSpeed: -1,\n      timer,\n    });\n    this.speedService.start();\n    this.speedService.subscribe((state) => {\n      this.emitter.emit(ReplayerEvents.StateChange, {\n        speed: state,\n      });\n    });\n\n    // rebuild first full snapshot as the poster of the player\n    // maybe we can cache it for performance optimization\n    const firstMeta = this.service.state.context.events.find(\n      (e) => e.type === EventType.Meta,\n    );\n    const firstFullsnapshot = this.service.state.context.events.find(\n      (e) => e.type === EventType.FullSnapshot,\n    );\n    if (firstMeta) {\n      const { width, height } = firstMeta.data as metaEvent['data'];\n      setTimeout(() => {\n        this.emitter.emit(ReplayerEvents.Resize, {\n          width,\n          height,\n        });\n      }, 0);\n    }\n    if (firstFullsnapshot) {\n      setTimeout(() => {\n        // when something has been played, there is no need to rebuild poster\n        if (this.firstPlayedEvent) {\n          return;\n        }\n        this.firstPlayedEvent = firstFullsnapshot;\n        this.rebuildFullSnapshot(\n          firstFullsnapshot as fullSnapshotEvent & { timestamp: number },\n        );\n        this.iframe.contentWindow!.scrollTo(\n          (firstFullsnapshot as fullSnapshotEvent).data.initialOffset,\n        );\n      }, 1);\n    }\n  }\n\n  public on(event: string, handler: Handler) {\n    this.emitter.on(event, handler);\n    return this;\n  }\n\n  public setConfig(config: Partial<playerConfig>) {\n    Object.keys(config).forEach((key) => {\n      // @ts-ignore\n      this.config[key] = config[key];\n    });\n    if (!this.config.skipInactive) {\n      this.backToNormal();\n    }\n    if (typeof config.speed !== 'undefined') {\n      this.speedService.send({\n        type: 'SET_SPEED',\n        payload: {\n          speed: config.speed!,\n        },\n      });\n    }\n    if (typeof config.mouseTail !== 'undefined') {\n      if (config.mouseTail === false) {\n        if (this.mouseTail) {\n          this.mouseTail.style.display = 'none';\n        }\n      } else {\n        if (!this.mouseTail) {\n          this.mouseTail = document.createElement('canvas');\n          this.mouseTail.width = Number.parseFloat(this.iframe.width);\n          this.mouseTail.height = Number.parseFloat(this.iframe.height);\n          this.mouseTail.classList.add('replayer-mouse-tail');\n          this.wrapper.insertBefore(this.mouseTail, this.iframe);\n        }\n        this.mouseTail.style.display = 'inherit';\n      }\n    }\n  }\n\n  public getMetaData(): playerMetaData {\n    const firstEvent = this.service.state.context.events[0];\n    const lastEvent = this.service.state.context.events[\n      this.service.state.context.events.length - 1\n    ];\n    return {\n      startTime: firstEvent.timestamp,\n      endTime: lastEvent.timestamp,\n      totalTime: lastEvent.timestamp - firstEvent.timestamp,\n    };\n  }\n\n  public getCurrentTime(): number {\n    return this.timer.timeOffset + this.getTimeOffset();\n  }\n\n  public getTimeOffset(): number {\n    const { baselineTime, events } = this.service.state.context;\n    return baselineTime - events[0].timestamp;\n  }\n\n  /**\n   * This API was designed to be used as play at any time offset.\n   * Since we minimized the data collected from recorder, we do not\n   * have the ability of undo an event.\n   * So the implementation of play at any time offset will always iterate\n   * all of the events, cast event before the offset synchronously\n   * and cast event after the offset asynchronously with timer.\n   * @param timeOffset number\n   */\n  public play(timeOffset = 0) {\n    if (this.service.state.matches('paused')) {\n      this.service.send({ type: 'PLAY', payload: { timeOffset } });\n    } else {\n      this.service.send({ type: 'PAUSE' });\n      this.service.send({ type: 'PLAY', payload: { timeOffset } });\n    }\n    this.iframe.contentDocument\n      ?.getElementsByTagName('html')[0]\n      .classList.remove('rrweb-paused');\n    this.emitter.emit(ReplayerEvents.Start);\n  }\n\n  public pause(timeOffset?: number) {\n    if (timeOffset === undefined && this.service.state.matches('playing')) {\n      this.service.send({ type: 'PAUSE' });\n    }\n    if (typeof timeOffset === 'number') {\n      this.play(timeOffset);\n      this.service.send({ type: 'PAUSE' });\n    }\n    this.iframe.contentDocument\n      ?.getElementsByTagName('html')[0]\n      .classList.add('rrweb-paused');\n    this.emitter.emit(ReplayerEvents.Pause);\n  }\n\n  public resume(timeOffset = 0) {\n    console.warn(\n      `The 'resume' will be departed in 1.0. Please use 'play' method which has the same interface.`,\n    );\n    this.play(timeOffset);\n    this.emitter.emit(ReplayerEvents.Resume);\n  }\n\n  public startLive(baselineTime?: number) {\n    this.service.send({ type: 'TO_LIVE', payload: { baselineTime } });\n  }\n\n  public addEvent(rawEvent: eventWithTime | string) {\n    const event = this.config.unpackFn\n      ? this.config.unpackFn(rawEvent as string)\n      : (rawEvent as eventWithTime);\n    Promise.resolve().then(() =>\n      this.service.send({ type: 'ADD_EVENT', payload: { event } }),\n    );\n  }\n\n  public enableInteract() {\n    this.iframe.setAttribute('scrolling', 'auto');\n    this.iframe.style.pointerEvents = 'auto';\n  }\n\n  public disableInteract() {\n    this.iframe.setAttribute('scrolling', 'no');\n    this.iframe.style.pointerEvents = 'none';\n  }\n\n  private setupDom() {\n    this.wrapper = document.createElement('div');\n    this.wrapper.classList.add('replayer-wrapper');\n    this.config.root!.appendChild(this.wrapper);\n\n    this.mouse = document.createElement('div');\n    this.mouse.classList.add('replayer-mouse');\n    this.wrapper.appendChild(this.mouse);\n\n    if (this.config.mouseTail !== false) {\n      this.mouseTail = document.createElement('canvas');\n      this.mouseTail.classList.add('replayer-mouse-tail');\n      this.mouseTail.style.display = 'inherit';\n      this.wrapper.appendChild(this.mouseTail);\n    }\n\n    this.iframe = document.createElement('iframe');\n    const attributes = ['allow-same-origin'];\n    if (this.config.UNSAFE_replayCanvas) {\n      attributes.push('allow-scripts');\n    }\n    // hide iframe before first meta event\n    this.iframe.style.display = 'none';\n    this.iframe.setAttribute('sandbox', attributes.join(' '));\n    this.disableInteract();\n    this.wrapper.appendChild(this.iframe);\n    if (this.iframe.contentWindow && this.iframe.contentDocument) {\n      smoothscrollPolyfill(\n        this.iframe.contentWindow,\n        this.iframe.contentDocument,\n      );\n\n      polyfill(this.iframe.contentWindow as Window & typeof globalThis);\n    }\n  }\n\n  private handleResize(dimension: viewportResizeDimension) {\n    this.iframe.style.display = 'inherit';\n    for (const el of [this.mouseTail, this.iframe]) {\n      if (!el) {\n        continue;\n      }\n      el.setAttribute('width', String(dimension.width));\n      el.setAttribute('height', String(dimension.height));\n    }\n  }\n\n  private getCastFn(event: eventWithTime, isSync = false) {\n    let castFn: undefined | (() => void);\n    switch (event.type) {\n      case EventType.DomContentLoaded:\n      case EventType.Load:\n        break;\n      case EventType.Custom:\n        castFn = () => {\n          /**\n           * emit custom-event and pass the event object.\n           *\n           * This will add more value to the custom event and allows the client to react for custom-event.\n           */\n          this.emitter.emit(ReplayerEvents.CustomEvent, event);\n        };\n        break;\n      case EventType.Meta:\n        castFn = () =>\n          this.emitter.emit(ReplayerEvents.Resize, {\n            width: event.data.width,\n            height: event.data.height,\n          });\n        break;\n      case EventType.FullSnapshot:\n        castFn = () => {\n          // Don't build a full snapshot during the first play through since we've already built it when the player was mounted.\n          if (this.firstPlayedEvent && this.firstPlayedEvent === event) {\n            return;\n          }\n          this.rebuildFullSnapshot(event, isSync);\n          this.iframe.contentWindow!.scrollTo(event.data.initialOffset);\n        };\n        break;\n      case EventType.IncrementalSnapshot:\n        castFn = () => {\n          this.applyIncremental(event, isSync);\n          if (isSync) {\n            // do not check skip in sync\n            return;\n          }\n          if (event === this.nextUserInteractionEvent) {\n            this.nextUserInteractionEvent = null;\n            this.backToNormal();\n          }\n          if (this.config.skipInactive && !this.nextUserInteractionEvent) {\n            for (const _event of this.service.state.context.events) {\n              if (_event.timestamp! <= event.timestamp!) {\n                continue;\n              }\n              if (this.isUserInteraction(_event)) {\n                if (\n                  _event.delay! - event.delay! >\n                  SKIP_TIME_THRESHOLD *\n                    this.speedService.state.context.timer.speed\n                ) {\n                  this.nextUserInteractionEvent = _event;\n                }\n                break;\n              }\n            }\n            if (this.nextUserInteractionEvent) {\n              const skipTime =\n                this.nextUserInteractionEvent.delay! - event.delay!;\n              const payload = {\n                speed: Math.min(\n                  Math.round(skipTime / SKIP_TIME_INTERVAL),\n                  this.config.maxSpeed,\n                ),\n              };\n              this.speedService.send({ type: 'FAST_FORWARD', payload });\n              this.emitter.emit(ReplayerEvents.SkipStart, payload);\n            }\n          }\n        };\n        break;\n      default:\n    }\n    const wrappedCastFn = () => {\n      if (castFn) {\n        castFn();\n      }\n      this.service.send({ type: 'CAST_EVENT', payload: { event } });\n\n      // events are kept sorted by timestamp, check if this is the last event\n      if (\n        event ===\n        this.service.state.context.events[\n          this.service.state.context.events.length - 1\n        ]\n      ) {\n        const finish = () => {\n          this.backToNormal();\n          this.service.send('END');\n          this.emitter.emit(ReplayerEvents.Finish);\n        };\n        if (\n          event.type === EventType.IncrementalSnapshot &&\n          event.data.source === IncrementalSource.MouseMove &&\n          event.data.positions.length\n        ) {\n          // defer finish event if the last event is a mouse move\n          setTimeout(() => {\n            finish();\n          }, Math.max(0, -event.data.positions[0].timeOffset + 50)); // Add 50 to make sure the timer would check the last mousemove event. Otherwise, the timer may be stopped by the service before checking the last event.\n        } else {\n          finish();\n        }\n      }\n    };\n    return wrappedCastFn;\n  }\n\n  private rebuildFullSnapshot(\n    event: fullSnapshotEvent & { timestamp: number },\n    isSync: boolean = false,\n  ) {\n    if (!this.iframe.contentDocument) {\n      return console.warn('Looks like your replayer has been destroyed.');\n    }\n    if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n      console.warn(\n        'Found unresolved missing node map',\n        this.legacy_missingNodeRetryMap,\n      );\n    }\n    this.legacy_missingNodeRetryMap = {};\n    const collected: AppendedIframe[] = [];\n    mirror.map = rebuild(event.data.node, {\n      doc: this.iframe.contentDocument,\n      afterAppend: (builtNode) => {\n        this.collectIframeAndAttachDocument(collected, builtNode);\n      },\n    })[1];\n    for (const { mutationInQueue, builtNode } of collected) {\n      this.attachDocumentToIframe(mutationInQueue, builtNode);\n      this.newDocumentQueue = this.newDocumentQueue.filter(\n        (m) => m !== mutationInQueue,\n      );\n      if (builtNode.contentDocument) {\n        const { documentElement, head } = builtNode.contentDocument;\n        this.insertStyleRules(documentElement, head);\n      }\n    }\n    const { documentElement, head } = this.iframe.contentDocument;\n    this.insertStyleRules(documentElement, head);\n    if (!this.service.state.matches('playing')) {\n      this.iframe.contentDocument\n        .getElementsByTagName('html')[0]\n        .classList.add('rrweb-paused');\n    }\n    this.emitter.emit(ReplayerEvents.FullsnapshotRebuilded, event);\n    if (!isSync) {\n      this.waitForStylesheetLoad();\n    }\n    if (this.config.UNSAFE_replayCanvas) {\n      this.preloadAllImages();\n    }\n  }\n\n  private insertStyleRules(\n    documentElement: HTMLElement,\n    head: HTMLHeadElement,\n  ) {\n    const styleEl = document.createElement('style');\n    documentElement!.insertBefore(styleEl, head);\n    const injectStylesRules = getInjectStyleRules(\n      this.config.blockClass,\n    ).concat(this.config.insertStyleRules);\n    if (this.config.pauseAnimation) {\n      injectStylesRules.push(\n        'html.rrweb-paused * { animation-play-state: paused !important; }',\n      );\n    }\n    for (let idx = 0; idx < injectStylesRules.length; idx++) {\n      (styleEl.sheet! as CSSStyleSheet).insertRule(injectStylesRules[idx], idx);\n    }\n  }\n\n  private attachDocumentToIframe(\n    mutation: addedNodeMutation,\n    iframeEl: HTMLIFrameElement,\n  ) {\n    const collected: AppendedIframe[] = [];\n    // If iframeEl is detached from dom, iframeEl.contentDocument is null.\n    if (!iframeEl.contentDocument) {\n      let parent = iframeEl.parentNode;\n      while (parent) {\n        // The parent of iframeEl is virtual parent and we need to mount it on the dom.\n        if (this.fragmentParentMap.has((parent as unknown) as INode)) {\n          const frag = (parent as unknown) as INode;\n          const realParent = this.fragmentParentMap.get(frag)!;\n          this.restoreRealParent(frag, realParent);\n          break;\n        }\n        parent = parent.parentNode;\n      }\n    }\n    buildNodeWithSN(mutation.node, {\n      doc: iframeEl.contentDocument!,\n      map: mirror.map,\n      hackCss: true,\n      skipChild: false,\n      afterAppend: (builtNode) => {\n        this.collectIframeAndAttachDocument(collected, builtNode);\n      },\n    });\n    for (const { mutationInQueue, builtNode } of collected) {\n      this.attachDocumentToIframe(mutationInQueue, builtNode);\n      this.newDocumentQueue = this.newDocumentQueue.filter(\n        (m) => m !== mutationInQueue,\n      );\n      if (builtNode.contentDocument) {\n        const { documentElement, head } = builtNode.contentDocument;\n        this.insertStyleRules(documentElement, head);\n      }\n    }\n  }\n\n  private collectIframeAndAttachDocument(\n    collected: AppendedIframe[],\n    builtNode: INode,\n  ) {\n    if (isIframeINode(builtNode)) {\n      const mutationInQueue = this.newDocumentQueue.find(\n        (m) => m.parentId === builtNode.__sn.id,\n      );\n      if (mutationInQueue) {\n        collected.push({ mutationInQueue, builtNode });\n      }\n    }\n  }\n\n  /**\n   * pause when loading style sheet, resume when loaded all timeout exceed\n   */\n  private waitForStylesheetLoad() {\n    const head = this.iframe.contentDocument?.head;\n    if (head) {\n      const unloadSheets: Set<HTMLLinkElement> = new Set();\n      let timer: number;\n      let beforeLoadState = this.service.state;\n      const stateHandler = () => {\n        beforeLoadState = this.service.state;\n      };\n      this.emitter.on(ReplayerEvents.Start, stateHandler);\n      this.emitter.on(ReplayerEvents.Pause, stateHandler);\n      const unsubscribe = () => {\n        this.emitter.off(ReplayerEvents.Start, stateHandler);\n        this.emitter.off(ReplayerEvents.Pause, stateHandler);\n      };\n      head\n        .querySelectorAll('link[rel=\"stylesheet\"]')\n        .forEach((css: HTMLLinkElement) => {\n          if (!css.sheet) {\n            unloadSheets.add(css);\n            css.addEventListener('load', () => {\n              unloadSheets.delete(css);\n              // all loaded and timer not released yet\n              if (unloadSheets.size === 0 && timer !== -1) {\n                if (beforeLoadState.matches('playing')) {\n                  this.play(this.getCurrentTime());\n                }\n                this.emitter.emit(ReplayerEvents.LoadStylesheetEnd);\n                if (timer) {\n                  window.clearTimeout(timer);\n                }\n                unsubscribe();\n              }\n            });\n          }\n        });\n\n      if (unloadSheets.size > 0) {\n        // find some unload sheets after iterate\n        this.service.send({ type: 'PAUSE' });\n        this.emitter.emit(ReplayerEvents.LoadStylesheetStart);\n        timer = window.setTimeout(() => {\n          if (beforeLoadState.matches('playing')) {\n            this.play(this.getCurrentTime());\n          }\n          // mark timer was called\n          timer = -1;\n          unsubscribe();\n        }, this.config.loadTimeout);\n      }\n    }\n  }\n\n  /**\n   * pause when there are some canvas drawImage args need to be loaded\n   */\n  private preloadAllImages() {\n    let beforeLoadState = this.service.state;\n    const stateHandler = () => {\n      beforeLoadState = this.service.state;\n    };\n    this.emitter.on(ReplayerEvents.Start, stateHandler);\n    this.emitter.on(ReplayerEvents.Pause, stateHandler);\n    const unsubscribe = () => {\n      this.emitter.off(ReplayerEvents.Start, stateHandler);\n      this.emitter.off(ReplayerEvents.Pause, stateHandler);\n    };\n    let count = 0;\n    let resolved = 0;\n    for (const event of this.service.state.context.events) {\n      if (\n        event.type === EventType.IncrementalSnapshot &&\n        event.data.source === IncrementalSource.CanvasMutation &&\n        event.data.property === 'drawImage' &&\n        typeof event.data.args[0] === 'string' &&\n        !this.imageMap.has(event)\n      ) {\n        count++;\n        const image = document.createElement('img');\n        image.src = event.data.args[0];\n        this.imageMap.set(event, image);\n        image.onload = () => {\n          resolved++;\n          if (resolved === count) {\n            if (beforeLoadState.matches('playing')) {\n              this.play(this.getCurrentTime());\n            }\n            unsubscribe();\n          }\n        };\n      }\n    }\n    if (count !== resolved) {\n      this.service.send({ type: 'PAUSE' });\n    }\n  }\n\n  private applyIncremental(\n    e: incrementalSnapshotEvent & { timestamp: number; delay?: number },\n    isSync: boolean,\n  ) {\n    const { data: d } = e;\n    switch (d.source) {\n      case IncrementalSource.Mutation: {\n        if (isSync) {\n          d.adds.forEach((m) => this.treeIndex.add(m));\n          d.texts.forEach((m) => this.treeIndex.text(m));\n          d.attributes.forEach((m) => this.treeIndex.attribute(m));\n          d.removes.forEach((m) => this.treeIndex.remove(m));\n        }\n        this.applyMutation(d, isSync);\n        break;\n      }\n      case IncrementalSource.MouseMove:\n        if (isSync) {\n          const lastPosition = d.positions[d.positions.length - 1];\n          this.moveAndHover(d, lastPosition.x, lastPosition.y, lastPosition.id);\n        } else {\n          d.positions.forEach((p) => {\n            const action = {\n              doAction: () => {\n                this.moveAndHover(d, p.x, p.y, p.id);\n              },\n              delay:\n                p.timeOffset +\n                e.timestamp -\n                this.service.state.context.baselineTime,\n            };\n            this.timer.addAction(action);\n          });\n          // add a dummy action to keep timer alive\n          this.timer.addAction({\n            doAction() {},\n            delay: e.delay! - d.positions[0]?.timeOffset,\n          });\n        }\n        break;\n      case IncrementalSource.MouseInteraction: {\n        /**\n         * Same as the situation of missing input target.\n         */\n        if (d.id === -1) {\n          break;\n        }\n        const event = new Event(MouseInteractions[d.type].toLowerCase());\n        const target = mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        this.emitter.emit(ReplayerEvents.MouseInteraction, {\n          type: d.type,\n          target,\n        });\n        const { triggerFocus } = this.config;\n        switch (d.type) {\n          case MouseInteractions.Blur:\n            if ('blur' in ((target as Node) as HTMLElement)) {\n              ((target as Node) as HTMLElement).blur();\n            }\n            break;\n          case MouseInteractions.Focus:\n            if (triggerFocus && ((target as Node) as HTMLElement).focus) {\n              ((target as Node) as HTMLElement).focus({\n                preventScroll: true,\n              });\n            }\n            break;\n          case MouseInteractions.Click:\n          case MouseInteractions.TouchStart:\n          case MouseInteractions.TouchEnd:\n            /**\n             * Click has no visual impact when replaying and may\n             * trigger navigation when apply to an <a> link.\n             * So we will not call click(), instead we add an\n             * animation to the mouse element which indicate user\n             * clicked at this moment.\n             */\n            if (!isSync) {\n              this.moveAndHover(d, d.x, d.y, d.id);\n              this.mouse.classList.remove('active');\n              // tslint:disable-next-line\n              void this.mouse.offsetWidth;\n              this.mouse.classList.add('active');\n            }\n            break;\n          default:\n            target.dispatchEvent(event);\n        }\n        break;\n      }\n      case IncrementalSource.Scroll: {\n        /**\n         * Same as the situation of missing input target.\n         */\n        if (d.id === -1) {\n          break;\n        }\n        if (isSync) {\n          this.treeIndex.scroll(d);\n          break;\n        }\n        this.applyScroll(d);\n        break;\n      }\n      case IncrementalSource.ViewportResize:\n        this.emitter.emit(ReplayerEvents.Resize, {\n          width: d.width,\n          height: d.height,\n        });\n        break;\n      case IncrementalSource.Input: {\n        /**\n         * Input event on an unserialized node usually means the event\n         * was synchrony triggered programmatically after the node was\n         * created. This means there was not an user observable interaction\n         * and we do not need to replay it.\n         */\n        if (d.id === -1) {\n          break;\n        }\n        if (isSync) {\n          this.treeIndex.input(d);\n          break;\n        }\n        this.applyInput(d);\n        break;\n      }\n      case IncrementalSource.MediaInteraction: {\n        const target = mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        const mediaEl = (target as Node) as HTMLMediaElement;\n        try {\n          if (d.type === MediaInteractions.Pause) {\n            mediaEl.pause();\n          }\n          if (d.type === MediaInteractions.Play) {\n            if (mediaEl.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {\n              mediaEl.play();\n            } else {\n              mediaEl.addEventListener('canplay', () => {\n                mediaEl.play();\n              });\n            }\n          }\n        } catch (error) {\n          if (this.config.showWarning) {\n            console.warn(\n              `Failed to replay media interactions: ${error.message || error}`,\n            );\n          }\n        }\n        break;\n      }\n      case IncrementalSource.StyleSheetRule: {\n        const target = mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n\n        const styleEl = (target as Node) as HTMLStyleElement;\n        const parent = (target.parentNode as unknown) as INode;\n        const usingVirtualParent = this.fragmentParentMap.has(parent);\n        let placeholderNode;\n\n        if (usingVirtualParent) {\n          /**\n           * styleEl.sheet is only accessible if the styleEl is part of the\n           * dom. This doesn't work on DocumentFragments so we have to re-add\n           * it to the dom temporarily.\n           */\n          const domParent = this.fragmentParentMap.get(\n            (target.parentNode as unknown) as INode,\n          );\n          placeholderNode = document.createTextNode('');\n          parent.replaceChild(placeholderNode, target);\n          domParent!.appendChild(target);\n        }\n\n        const styleSheet: CSSStyleSheet = styleEl.sheet!;\n\n        if (d.adds) {\n          d.adds.forEach(({ rule, index }) => {\n            try {\n              const _index =\n                index === undefined\n                  ? undefined\n                  : Math.min(index, styleSheet.rules.length);\n              try {\n                styleSheet.insertRule(rule, _index);\n              } catch (e) {\n                /**\n                 * sometimes we may capture rules with browser prefix\n                 * insert rule with prefixs in other browsers may cause Error\n                 */\n              }\n            } catch (e) {\n              /**\n               * accessing styleSheet rules may cause SecurityError\n               * for specific access control settings\n               */\n            }\n          });\n        }\n\n        if (d.removes) {\n          d.removes.forEach(({ index }) => {\n            try {\n              styleSheet.deleteRule(index);\n            } catch (e) {\n              /**\n               * same as insertRule\n               */\n            }\n          });\n        }\n\n        if (usingVirtualParent && placeholderNode) {\n          parent.replaceChild(target, placeholderNode);\n        }\n\n        break;\n      }\n      case IncrementalSource.CanvasMutation: {\n        if (!this.config.UNSAFE_replayCanvas) {\n          return;\n        }\n        const target = mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        try {\n          const ctx = ((target as unknown) as HTMLCanvasElement).getContext(\n            '2d',\n          )!;\n          if (d.setter) {\n            // skip some read-only type checks\n            // tslint:disable-next-line:no-any\n            (ctx as any)[d.property] = d.args[0];\n            return;\n          }\n          const original = ctx[\n            d.property as keyof CanvasRenderingContext2D\n          ] as Function;\n          /**\n           * We have serialized the image source into base64 string during recording,\n           * which has been preloaded before replay.\n           * So we can get call drawImage SYNCHRONOUSLY which avoid some fragile cast.\n           */\n          if (d.property === 'drawImage' && typeof d.args[0] === 'string') {\n            const image = this.imageMap.get(e);\n            d.args[0] = image;\n            original.apply(ctx, d.args);\n          } else {\n            original.apply(ctx, d.args);\n          }\n        } catch (error) {\n          this.warnCanvasMutationFailed(d, d.id, error);\n        }\n        break;\n      }\n      case IncrementalSource.Font: {\n        try {\n          const fontFace = new FontFace(\n            d.family,\n            d.buffer ? new Uint8Array(JSON.parse(d.fontSource)) : d.fontSource,\n            d.descriptors,\n          );\n          this.iframe.contentDocument?.fonts.add(fontFace);\n        } catch (error) {\n          if (this.config.showWarning) {\n            console.warn(error);\n          }\n        }\n        break;\n      }\n      case IncrementalSource.Log: {\n        try {\n          const logData = e.data as logData;\n          const replayLogger = this.config.logConfig.replayLogger!;\n          if (typeof replayLogger[logData.level] === 'function') {\n            replayLogger[logData.level]!(logData);\n          }\n        } catch (error) {\n          if (this.config.showWarning) {\n            console.warn(error);\n          }\n        }\n      }\n      default:\n    }\n  }\n\n  private applyMutation(d: mutationData, useVirtualParent: boolean) {\n    d.removes.forEach((mutation) => {\n      const target = mirror.getNode(mutation.id);\n      if (!target) {\n        return this.warnNodeNotFound(d, mutation.id);\n      }\n      let parent: INode | null | ShadowRoot = mirror.getNode(mutation.parentId);\n      if (!parent) {\n        return this.warnNodeNotFound(d, mutation.parentId);\n      }\n      if (mutation.isShadow && hasShadowRoot(parent)) {\n        parent = parent.shadowRoot;\n      }\n      // target may be removed with its parents before\n      mirror.removeNodeFromMap(target);\n      if (parent) {\n        try {\n          const realParent =\n            '__sn' in parent ? this.fragmentParentMap.get(parent) : undefined;\n          if (realParent && realParent.contains(target)) {\n            realParent.removeChild(target);\n          } else if (this.fragmentParentMap.has(target)) {\n            /**\n             * the target itself is a fragment document and it's not in the dom\n             * so we should remove the real target from its parent\n             */\n            const realTarget = this.fragmentParentMap.get(target)!;\n            parent.removeChild(realTarget);\n            this.fragmentParentMap.delete(target);\n          } else {\n            parent.removeChild(target);\n          }\n        } catch (error) {\n          console.warn('issue#88');\n        }\n      }\n    });\n\n    // tslint:disable-next-line: variable-name\n    const legacy_missingNodeMap: missingNodeMap = {\n      ...this.legacy_missingNodeRetryMap,\n    };\n    const queue: addedNodeMutation[] = [];\n\n    // next not present at this moment\n    function nextNotInDOM(mutation: addedNodeMutation) {\n      let next: Node | null = null;\n      if (mutation.nextId) {\n        next = mirror.getNode(mutation.nextId) as Node;\n      }\n      // next not present at this moment\n      if (\n        mutation.nextId !== null &&\n        mutation.nextId !== undefined &&\n        mutation.nextId !== -1 &&\n        !next\n      ) {\n        return true;\n      }\n      return false;\n    }\n\n    const appendNode = (mutation: addedNodeMutation) => {\n      if (!this.iframe.contentDocument) {\n        return console.warn('Looks like your replayer has been destroyed.');\n      }\n      let parent: INode | null | ShadowRoot = mirror.getNode(mutation.parentId);\n      if (!parent) {\n        if (mutation.node.type === NodeType.Document) {\n          // is newly added document, maybe the document node of an iframe\n          return this.newDocumentQueue.push(mutation);\n        }\n        return queue.push(mutation);\n      }\n\n      let parentInDocument = null;\n      if (this.iframe.contentDocument.contains) {\n        parentInDocument = this.iframe.contentDocument.contains(parent);\n      } else if (this.iframe.contentDocument.body.contains) {\n        // fix for IE\n        // refer 'Internet Explorer notes' at https://developer.mozilla.org/zh-CN/docs/Web/API/Document\n        parentInDocument = this.iframe.contentDocument.body.contains(parent);\n      }\n\n      const hasIframeChild =\n        ((parent as unknown) as HTMLElement).getElementsByTagName?.('iframe')\n          .length > 0;\n      /**\n       * Why !isIframeINode(parent)? If parent element is an iframe, iframe document can't be appended to virtual parent.\n       * Why !hasIframeChild? If we move iframe elements from dom to fragment document, we will lose the contentDocument of iframe. So we need to disable the virtual dom optimization if a parent node contains iframe elements.\n       */\n      if (\n        useVirtualParent &&\n        parentInDocument &&\n        !isIframeINode(parent) &&\n        !hasIframeChild\n      ) {\n        const virtualParent = (document.createDocumentFragment() as unknown) as INode;\n        mirror.map[mutation.parentId] = virtualParent;\n        this.fragmentParentMap.set(virtualParent, parent);\n\n        // store the state, like scroll position, of child nodes before they are unmounted from dom\n        this.storeState(parent);\n\n        while (parent.firstChild) {\n          virtualParent.appendChild(parent.firstChild);\n        }\n        parent = virtualParent;\n      }\n\n      if (mutation.node.isShadow && hasShadowRoot(parent)) {\n        parent = parent.shadowRoot;\n      }\n\n      let previous: Node | null = null;\n      let next: Node | null = null;\n      if (mutation.previousId) {\n        previous = mirror.getNode(mutation.previousId) as Node;\n      }\n      if (mutation.nextId) {\n        next = mirror.getNode(mutation.nextId) as Node;\n      }\n      if (nextNotInDOM(mutation)) {\n        return queue.push(mutation);\n      }\n\n      if (mutation.node.rootId && !mirror.getNode(mutation.node.rootId)) {\n        return;\n      }\n\n      const targetDoc = mutation.node.rootId\n        ? mirror.getNode(mutation.node.rootId)\n        : this.iframe.contentDocument;\n      if (isIframeINode(parent)) {\n        this.attachDocumentToIframe(mutation, parent);\n        return;\n      }\n      const target = buildNodeWithSN(mutation.node, {\n        doc: targetDoc as Document,\n        map: mirror.map,\n        skipChild: true,\n        hackCss: true,\n      }) as INode;\n\n      // legacy data, we should not have -1 siblings any more\n      if (mutation.previousId === -1 || mutation.nextId === -1) {\n        legacy_missingNodeMap[mutation.node.id] = {\n          node: target,\n          mutation,\n        };\n        return;\n      }\n\n      if (previous && previous.nextSibling && previous.nextSibling.parentNode) {\n        parent.insertBefore(target, previous.nextSibling);\n      } else if (next && next.parentNode) {\n        // making sure the parent contains the reference nodes\n        // before we insert target before next.\n        parent.contains(next)\n          ? parent.insertBefore(target, next)\n          : parent.insertBefore(target, null);\n      } else {\n        /**\n         * Sometimes the document changes and the MutationObserver is disconnected, so the removal of child elements can't be detected and recorded. After the change of document, we may get another mutation which adds a new html element, while the old html element still exists in the dom, and we need to remove the old html element first to avoid collision.\n         */\n        if (parent === targetDoc) {\n          while (targetDoc.firstChild) {\n            targetDoc.removeChild(targetDoc.firstChild);\n          }\n        }\n\n        parent.appendChild(target);\n      }\n\n      if (isIframeINode(target)) {\n        const mutationInQueue = this.newDocumentQueue.find(\n          (m) => m.parentId === target.__sn.id,\n        );\n        if (mutationInQueue) {\n          this.attachDocumentToIframe(mutationInQueue, target);\n          this.newDocumentQueue = this.newDocumentQueue.filter(\n            (m) => m !== mutationInQueue,\n          );\n        }\n        if (target.contentDocument) {\n          const { documentElement, head } = target.contentDocument;\n          this.insertStyleRules(documentElement, head);\n        }\n      }\n\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(\n          legacy_missingNodeMap,\n          parent,\n          target,\n          mutation,\n        );\n      }\n    };\n\n    d.adds.forEach((mutation) => {\n      appendNode(mutation);\n    });\n\n    let startTime = Date.now();\n    while (queue.length) {\n      // transform queue to resolve tree\n      const resolveTrees = queueToResolveTrees(queue);\n      queue.length = 0;\n      if (Date.now() - startTime > 500) {\n        this.warn(\n          'Timeout in the loop, please check the resolve tree data:',\n          resolveTrees,\n        );\n        break;\n      }\n      for (const tree of resolveTrees) {\n        let parent = mirror.getNode(tree.value.parentId);\n        if (!parent) {\n          this.debug(\n            'Drop resolve tree since there is no parent for the root node.',\n            tree,\n          );\n        } else {\n          iterateResolveTree(tree, (mutation) => {\n            appendNode(mutation);\n          });\n        }\n      }\n    }\n\n    if (Object.keys(legacy_missingNodeMap).length) {\n      Object.assign(this.legacy_missingNodeRetryMap, legacy_missingNodeMap);\n    }\n\n    d.texts.forEach((mutation) => {\n      let target = mirror.getNode(mutation.id);\n      if (!target) {\n        return this.warnNodeNotFound(d, mutation.id);\n      }\n      /**\n       * apply text content to real parent directly\n       */\n      if (this.fragmentParentMap.has(target)) {\n        target = this.fragmentParentMap.get(target)!;\n      }\n      target.textContent = mutation.value;\n    });\n    d.attributes.forEach((mutation) => {\n      let target = mirror.getNode(mutation.id);\n      if (!target) {\n        return this.warnNodeNotFound(d, mutation.id);\n      }\n      if (this.fragmentParentMap.has(target)) {\n        target = this.fragmentParentMap.get(target)!;\n      }\n      for (const attributeName in mutation.attributes) {\n        if (typeof attributeName === 'string') {\n          const value = mutation.attributes[attributeName];\n          try {\n            if (value !== null) {\n              ((target as Node) as Element).setAttribute(attributeName, value);\n            } else {\n              ((target as Node) as Element).removeAttribute(attributeName);\n            }\n          } catch (error) {\n            if (this.config.showWarning) {\n              console.warn(\n                'An error occurred may due to the checkout feature.',\n                error,\n              );\n            }\n          }\n        }\n      }\n    });\n  }\n\n  private applyScroll(d: scrollData) {\n    const target = mirror.getNode(d.id);\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n    if ((target as Node) === this.iframe.contentDocument) {\n      this.iframe.contentWindow!.scrollTo({\n        top: d.y,\n        left: d.x,\n        behavior: 'smooth',\n      });\n    } else {\n      try {\n        ((target as Node) as Element).scrollTop = d.y;\n        ((target as Node) as Element).scrollLeft = d.x;\n      } catch (error) {\n        /**\n         * Seldomly we may found scroll target was removed before\n         * its last scroll event.\n         */\n      }\n    }\n  }\n\n  private applyInput(d: inputData) {\n    const target = mirror.getNode(d.id);\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n    try {\n      ((target as Node) as HTMLInputElement).checked = d.isChecked;\n      ((target as Node) as HTMLInputElement).value = d.text;\n    } catch (error) {\n      // for safe\n    }\n  }\n\n  /**\n   * format the trace data to a string\n   * @param data the log data\n   */\n  private formatMessage(data: logData): string {\n    if (data.trace.length === 0) {\n      return '';\n    }\n    const stackPrefix = '\\n\\tat ';\n    let result = stackPrefix;\n    result += data.trace.join(stackPrefix);\n    return result;\n  }\n\n  /**\n   * generate a console log replayer which implement the interface ReplayLogger\n   */\n  private getConsoleLogger(): ReplayLogger {\n    const replayLogger: ReplayLogger = {};\n    for (const level of this.config.logConfig.level!) {\n      if (level === 'trace') {\n        replayLogger[level] = (data: logData) => {\n          const logger = ((console.log as unknown) as PatchedConsoleLog)[\n            ORIGINAL_ATTRIBUTE_NAME\n          ]\n            ? ((console.log as unknown) as PatchedConsoleLog)[\n                ORIGINAL_ATTRIBUTE_NAME\n              ]\n            : console.log;\n          logger(\n            ...data.payload.map((s) => JSON.parse(s)),\n            this.formatMessage(data),\n          );\n        };\n      } else {\n        replayLogger[level] = (data: logData) => {\n          const logger = ((console[level] as unknown) as PatchedConsoleLog)[\n            ORIGINAL_ATTRIBUTE_NAME\n          ]\n            ? ((console[level] as unknown) as PatchedConsoleLog)[\n                ORIGINAL_ATTRIBUTE_NAME\n              ]\n            : console[level];\n          logger(\n            ...data.payload.map((s) => JSON.parse(s)),\n            this.formatMessage(data),\n          );\n        };\n      }\n    }\n    return replayLogger;\n  }\n\n  private legacy_resolveMissingNode(\n    map: missingNodeMap,\n    parent: Node,\n    target: Node,\n    targetMutation: addedNodeMutation,\n  ) {\n    const { previousId, nextId } = targetMutation;\n    const previousInMap = previousId && map[previousId];\n    const nextInMap = nextId && map[nextId];\n    if (previousInMap) {\n      const { node, mutation } = previousInMap as missingNode;\n      parent.insertBefore(node, target);\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node as Node, mutation);\n      }\n    }\n    if (nextInMap) {\n      const { node, mutation } = nextInMap as missingNode;\n      parent.insertBefore(node, target.nextSibling);\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node as Node, mutation);\n      }\n    }\n  }\n\n  private moveAndHover(d: incrementalData, x: number, y: number, id: number) {\n    const target = mirror.getNode(id);\n    if (!target) {\n      return this.debugNodeNotFound(d, id);\n    }\n\n    const base = getBaseDimension(target, this.iframe);\n    const _x = x * base.absoluteScale + base.x;\n    const _y = y * base.absoluteScale + base.y;\n\n    this.mouse.style.left = `${_x}px`;\n    this.mouse.style.top = `${_y}px`;\n    this.drawMouseTail({ x: _x, y: _y });\n    this.hoverElements((target as Node) as Element);\n  }\n\n  private drawMouseTail(position: { x: number; y: number }) {\n    if (!this.mouseTail) {\n      return;\n    }\n\n    const { lineCap, lineWidth, strokeStyle, duration } =\n      this.config.mouseTail === true\n        ? defaultMouseTailConfig\n        : Object.assign({}, defaultMouseTailConfig, this.config.mouseTail);\n\n    const draw = () => {\n      if (!this.mouseTail) {\n        return;\n      }\n      const ctx = this.mouseTail.getContext('2d');\n      if (!ctx || !this.tailPositions.length) {\n        return;\n      }\n      ctx.clearRect(0, 0, this.mouseTail.width, this.mouseTail.height);\n      ctx.beginPath();\n      ctx.lineWidth = lineWidth;\n      ctx.lineCap = lineCap;\n      ctx.strokeStyle = strokeStyle;\n      ctx.moveTo(this.tailPositions[0].x, this.tailPositions[0].y);\n      this.tailPositions.forEach((p) => ctx.lineTo(p.x, p.y));\n      ctx.stroke();\n    };\n\n    this.tailPositions.push(position);\n    draw();\n    setTimeout(() => {\n      this.tailPositions = this.tailPositions.filter((p) => p !== position);\n      draw();\n    }, duration / this.speedService.state.context.timer.speed);\n  }\n\n  private hoverElements(el: Element) {\n    this.iframe.contentDocument\n      ?.querySelectorAll('.\\\\:hover')\n      .forEach((hoveredEl) => {\n        hoveredEl.classList.remove(':hover');\n      });\n    let currentEl: Element | null = el;\n    while (currentEl) {\n      if (currentEl.classList) {\n        currentEl.classList.add(':hover');\n      }\n      currentEl = currentEl.parentElement;\n    }\n  }\n\n  private isUserInteraction(event: eventWithTime): boolean {\n    if (event.type !== EventType.IncrementalSnapshot) {\n      return false;\n    }\n    return (\n      event.data.source > IncrementalSource.Mutation &&\n      event.data.source <= IncrementalSource.Input\n    );\n  }\n\n  private backToNormal() {\n    this.nextUserInteractionEvent = null;\n    if (this.speedService.state.matches('normal')) {\n      return;\n    }\n    this.speedService.send({ type: 'BACK_TO_NORMAL' });\n    this.emitter.emit(ReplayerEvents.SkipEnd, {\n      speed: this.speedService.state.context.normalSpeed,\n    });\n  }\n\n  /**\n   * Replace the virtual parent with the real parent.\n   * @param frag fragment document, the virtual parent\n   * @param parent real parent element\n   */\n  private restoreRealParent(frag: INode, parent: INode) {\n    mirror.map[parent.__sn.id] = parent;\n    /**\n     * If we have already set value attribute on textarea,\n     * then we could not apply text content as default value any more.\n     */\n    if (\n      parent.__sn.type === NodeType.Element &&\n      parent.__sn.tagName === 'textarea' &&\n      frag.textContent\n    ) {\n      ((parent as unknown) as HTMLTextAreaElement).value = frag.textContent;\n    }\n    parent.appendChild(frag);\n    // restore state of elements after they are mounted\n    this.restoreState(parent);\n  }\n\n  /**\n   * store state of elements before unmounted from dom recursively\n   * the state should be restored in the handler of event ReplayerEvents.Flush\n   * e.g. browser would lose scroll position after the process that we add children of parent node to Fragment Document as virtual dom\n   */\n  private storeState(parent: INode) {\n    if (parent) {\n      if (parent.nodeType === parent.ELEMENT_NODE) {\n        const parentElement = (parent as unknown) as HTMLElement;\n        if (parentElement.scrollLeft || parentElement.scrollTop) {\n          // store scroll position state\n          this.elementStateMap.set(parent, {\n            scroll: [parentElement.scrollLeft, parentElement.scrollTop],\n          });\n        }\n        const children = parentElement.children;\n        for (const child of Array.from(children)) {\n          this.storeState((child as unknown) as INode);\n        }\n      }\n    }\n  }\n\n  /**\n   * restore the state of elements recursively, which was stored before elements were unmounted from dom in virtual parent mode\n   * this function corresponds to function storeState\n   */\n  private restoreState(parent: INode) {\n    if (parent.nodeType === parent.ELEMENT_NODE) {\n      const parentElement = (parent as unknown) as HTMLElement;\n      if (this.elementStateMap.has(parent)) {\n        const storedState = this.elementStateMap.get(parent)!;\n        // restore scroll position\n        if (storedState.scroll) {\n          parentElement.scrollLeft = storedState.scroll[0];\n          parentElement.scrollTop = storedState.scroll[1];\n        }\n        this.elementStateMap.delete(parent);\n      }\n      const children = parentElement.children;\n      for (const child of Array.from(children)) {\n        this.restoreState((child as unknown) as INode);\n      }\n    }\n  }\n\n  private warnNodeNotFound(d: incrementalData, id: number) {\n    this.warn(`Node with id '${id}' not found in`, d);\n  }\n\n  private warnCanvasMutationFailed(\n    d: canvasMutationData,\n    id: number,\n    error: unknown,\n  ) {\n    this.warn(`Has error on update canvas '${id}'`, d, error);\n  }\n\n  private debugNodeNotFound(d: incrementalData, id: number) {\n    /**\n     * There maybe some valid scenes of node not being found.\n     * Because DOM events are macrotask and MutationObserver callback\n     * is microtask, so events fired on a removed DOM may emit\n     * snapshots in the reverse order.\n     */\n    this.debug(REPLAY_CONSOLE_PREFIX, `Node with id '${id}' not found in`, d);\n  }\n\n  private warn(...args: Parameters<typeof console.warn>) {\n    if (!this.config.showWarning) {\n      return;\n    }\n    console.warn(REPLAY_CONSOLE_PREFIX, ...args);\n  }\n\n  private debug(...args: Parameters<typeof console.log>) {\n    if (!this.config.showDebug) {\n      return;\n    }\n    // tslint:disable-next-line: no-console\n    console.log(REPLAY_CONSOLE_PREFIX, ...args);\n  }\n}\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Much of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// Many optimizations have been made, so the bundle size is ultimately smaller but performance is similar.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var u = ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c], { type: 'text/javascript' })));\n    var w = new Worker(u);\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i)\n            co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = hMap(flt, 9, 0), flrm = hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = hMap(fdt, 5, 0), fdrm = hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) >> 0;\n    return ((d[o] | (d[o + 1] << 8)) >>> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) >> 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >>> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) >> 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    if (final && !lm)\n        return buf;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                if (!noSt && pos + tl * (clb + 7) > tbts)\n                    break;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts)\n                throw 'unexpected EOF';\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var mxa = lbt + dbt + 18;\n        while (noSt || pos + mxa < tbts) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts)\n                throw 'unexpected EOF';\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts)\n                    throw 'unexpected EOF';\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = pos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) >> 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) >> 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [new u8(0), 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.floor(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768\n            var imod = i & 32767;\n            // previous index with this value\n            var pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst)\n            pos = wfblk(w, pos, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = new u32(256);\nfor (var i = 0; i < 256; ++i) {\n    var c = i, k = 9;\n    while (--k)\n        c = ((c & 1) && 0xEDB88320) ^ (c >>> 1);\n    crct[i] = c;\n}\n// CRC32\nvar crc = function () {\n    var c = 0xFFFFFFFF;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return c ^ 0xFFFFFFFF; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 5552, l);\n                for (; i < e; ++i)\n                    n += d[i], m += n;\n                n %= 65521, m %= 65521;\n            }\n            a = n, b = m;\n        },\n        d: function () { return ((a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8)) + ((a & 255) << 23) * 2; }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\n// worker onmessage\nvar wom = function (ev) {\n    for (var k in ev.data[0])\n        self[k] = ev.data[0][k];\n    onmessage = new Function('return ' + ev.data[1])();\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=' + wom.toString(), id, [td, init.toString()], cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    if (!opts.consume)\n        dat = new u8(dat);\n    w.postMessage([dat, opts], [dat.buffer]);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16)) + (d[b + 3] << 23) * 2; };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) + (2 * (d[l - 1] << 23));\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    return dopt(data, opts, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), final || false);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = 32768;\n        this.p = slc(this.p, (this.s.p / 8) >> 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = gzs(this.p);\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    var l = str.length;\n    if (!latin1 && typeof TextEncoder != 'undefined')\n        return new TextEncoder().encode(str);\n    var ar = new u8(str.length + (str.length >>> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >>> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >>> 18)), w(128 | ((c >>> 12) & 63)), w(128 | ((c >>> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >>> 12)), w(128 | ((c >>> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    var r = '';\n    if (!latin1 && typeof TextDecoder != 'undefined')\n        return new TextDecoder().decode(dat);\n    for (var i = 0; i < dat.length;) {\n        var c = dat[i++];\n        if (c < 128 || latin1)\n            r += String.fromCharCode(c);\n        else if (c < 224)\n            r += String.fromCharCode((c & 31) << 6 | (dat[i++] & 63));\n        else if (c < 240)\n            r += String.fromCharCode((c & 15) << 12 | (dat[i++] & 63) << 6 | (dat[i++] & 63));\n        else\n            c = ((c & 15) << 18 | (dat[i++] & 63) << 12 | (dat[i++] & 63) << 6 | (dat[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n    }\n    return r;\n}\n;\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b) {\n    var u = b2(d, b + 8) & 2048, c = b2(d, b + 10), sc = b4(d, b + 20), su = b4(d, b + 24), fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !u);\n    return [sc, c, su, fn, b + 46 + fnl + b2(d, b + 30) + b2(d, b + 32), b4(d, b + 42)];\n};\n// write zip header\nvar wzh = function (d, b, c, cmp, su, fn, u, o, ce, t) {\n    var fl = fn.length, l = cmp.length;\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b] = 20, b += 2;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (t == 8 && (o.level == 1 ? 6 : o.level < 6 ? 4 : o.level == 9 ? 2 : 0)), d[b++] = u && 8;\n    d[b] = t, b += 2;\n    var dt = new Date(o.mtime || Date.now()), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, ((y << 24) * 2) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1));\n    b += 4;\n    wbytes(d, b, c);\n    wbytes(d, b + 4, l);\n    wbytes(d, b + 8, su);\n    wbytes(d, b + 12, fl), b += 16; // skip extra field, comment\n    if (ce != null)\n        wbytes(d, b += 10, ce), b += 4;\n    d.set(fn, b);\n    b += fl;\n    if (ce == null)\n        d.set(cmp, b);\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                wzh(out, tot, f.c, f.d, f.m, f.n, f.u, f.p, null, f.t);\n                wzh(out, o, f.c, f.d, f.m, f.n, f.u, f.p, tot, f.t), o += 46 + f.n.length, tot += 30 + f.n.length + f.d.length;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), m = file.length;\n        c.p(file);\n        var n = strToU8(fn), s = n.length;\n        var t = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = {\n                    t: t,\n                    d: d,\n                    m: m,\n                    c: c.d(),\n                    u: fn.length != l,\n                    n: n,\n                    p: p\n                };\n                o += 30 + s + l;\n                tot += 76 + 2 * s + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (n.length > 65535)\n            cbl('filename too long', null);\n        if (!t)\n            cbl(null, file);\n        else if (m < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var t = p.level == 0 ? 0 : 8;\n        var n = strToU8(fn), s = n.length;\n        if (n.length > 65535)\n            throw 'filename too long';\n        var d = t ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push({\n            t: t,\n            d: d,\n            m: file.length,\n            c: c.d(),\n            u: fn.length != s,\n            n: n,\n            o: o,\n            p: p\n        });\n        o += 30 + s + l;\n        tot += 76 + 2 * s + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f.c, f.d, f.m, f.n, f.u, f.p, null, f.t);\n        wzh(out, o, f.c, f.d, f.m, f.n, f.u, f.p, f.o, f.t), o += 46 + f.n.length;\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var _loop_2 = function (i) {\n        var _a = zh(data, o), sc = _a[0], c_1 = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                inflate(infl, { size: su }, cbl);\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_2(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o), sc = _a[0], c_2 = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n","import { strFromU8, strToU8, unzlibSync } from 'fflate';\nimport { UnpackFn, eventWithTimeAndPacker, MARK } from './base';\nimport { eventWithTime } from '../types';\n\nexport const unpack: UnpackFn = (raw: string) => {\n  if (typeof raw !== 'string') {\n    return raw;\n  }\n  try {\n    const e: eventWithTime = JSON.parse(raw);\n    if (e.timestamp) {\n      return e;\n    }\n  } catch (error) {\n    // ignore and continue\n  }\n  try {\n    const e: eventWithTimeAndPacker = JSON.parse(\n      strFromU8(unzlibSync(strToU8(raw, true)))\n    );\n    if (e.v === MARK) {\n      return e;\n    }\n    throw new Error(\n      `These events were packed with packer ${e.v} which is incompatible with current packer ${MARK}.`,\n    );\n  } catch (error) {\n    console.error(error);\n    throw new Error('Unknown data format.');\n  }\n};\n","import { eventWithTime } from '../types';\n\nexport type PackFn = (event: eventWithTime) => string;\nexport type UnpackFn = (raw: string) => eventWithTime;\n\nexport type eventWithTimeAndPacker = eventWithTime & {\n  v: string;\n};\n\nexport const MARK = 'v1';\n"],"names":["NodeType","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__values","o","Symbol","iterator","m","next","value","done","TypeError","__read","r","e","ar","push","error","__spread","concat","isElement","nodeType","ELEMENT_NODE","commentre","parse","css","options","lineno","column","updatePosition","str","lines","match","lastIndexOf","position","start","line","node","Position","whitespace","end","source","content","errorsList","msg","err","Error","reason","filename","silent","open","close","rules","comments","charAt","atrule","rule","re","exec","slice","c","comment","pos","type","selector","trim","replace","split","map","declaration","propMatch","prop","val","ret","property","declarations","decl","decls","keyframe","vals","values","rulesList","atimport","_compileAtrule","atcharset","atnamespace","name","RegExp","vendor","frame","frames","keyframes","atkeyframes","media","style","atmedia","atcustommedia","supports","atsupports","doc","document","atdocument","sel","selectors","atpage","athost","atfontface","addParent","obj","parent","isNode","childParent","_i","_a","keys","k","Array","isArray","forEach","v","defineProperty","configurable","writable","enumerable","stylesheet","parsingErrors","tagMap","script","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","HOVER_SELECTOR","HOVER_SELECTOR_GLOBAL","addHoverClass","cssText","ast","test","selectorMatcher","filter","index","indexOf","sort","a","b","join","newSelector","buildNode","hackCss","Document","implementation","createDocument","DocumentType","createDocumentType","publicId","systemId","Element","node_1","tagName","attributes","_cssText","getTagName","isSVG","createElementNS","createElement","_loop_1","startsWith","image_1","src","onload","ctx","getContext","drawImage","width","height","play","pause","isTextarea","isRemoteOrDynamicCss","child","createTextNode","from","childNodes","TEXT_NODE","removeChild","appendChild","setAttributeNS","substring","setAttribute","isShadowHost","shadowRoot","firstChild","attachShadow","mode","Text","isStyle","textContent","CDATA","createCDATASection","Comment","createComment","buildNodeWithSN","skipChild","_b","afterAppend","rootId","console","assert","__sn","id","_c","childN","childNode","isShadow","warn","rebuild","onVisit","idNodeMap","key","visit","visitedNode","el","scrollLeft","scrollTop","handleScroll","mitt","all","create","on","handler","off","splice","emit","evt","EventType","IncrementalSource","MouseInteractions","MediaInteractions","ReplayerEvents","polyfill","w","d","documentElement","__forceSmoothScrollPolyfill__","userAgent","HTMLElement","original","scroll","scrollTo","scrollBy","elementScroll","scrollElement","scrollIntoView","now","performance","bind","Date","ROUNDING_TOLERANCE","navigator","undefined","shouldBailOut","smoothScroll","body","left","scrollX","pageXOffset","top","scrollY","pageYOffset","SyntaxError","behavior","scrollableParent","findScrollableParent","parentRects","getBoundingClientRect","clientRects","getComputedStyle","x","y","firstArg","hasScrollableSpace","axis","clientHeight","scrollHeight","clientWidth","scrollWidth","canOverflow","overflowValue","isScrollable","isScrollableY","isScrollableX","parentNode","host","step","context","currentX","currentY","elapsed","startTime","Math","cos","PI","ease","startX","startY","method","scrollable","requestAnimationFrame","actions","speed","Timer","action","findActionIndex","timeOffset","lastTimestamp","self","raf","check","time","delay","shift","doAction","liveMode","cancelAnimationFrame","mid","floor","addDelay","event","baselineTime","IncrementalSnapshot","data","MouseMove","firstOffset","positions","firstTimestamp","timestamp","NotStarted","Running","Stopped","assignment","u","changed","matches","config","_options","initialState","initial","states","entry","transition","f","l","g","target","cond","h","exit","S","return","Set","_machine","send","subscribe","add","unsubscribe","delete","stop","clear","state","status","mirror","getId","getNode","removeNodeFromMap","has","reset","TreeIndex","mutation","parentTreeNode","indexes","get","parentId","treeNode","children","texts","tree","set","deepRemoveFromMirror","_this","removeIdSet","deepRemoveFromTreeIndex","_treeNode","_parentTreeNode","removeNodeMutations","textMutations","attributeMutations","scrollMap","inputMap","batchMutationData","Mutation","removes","adds","walk","removed","_d","_f","Map","mutationData","queueToResolveTrees","queue","queueNodeMap","putIntoMap","nodeInTree","queueNodeTrees","queue_1","nextId","nextInTree","idx","parentInTree","iterateResolveTree","cb","isIframeINode","hasShadowRoot","Boolean","createPlayerService","getCastFn","emitter","interpret","createMachine","playing","PAUSE","CAST_EVENT","END","ADD_EVENT","paused","PLAY","TO_LIVE","live","castEvent","lastPlayedEvent","payload","recordTimeOffset","events","timer","events_1","neededEvents","Meta","discardPriorSnapshots","lastPlayedTimestamp","PlayBack","isSync","DomContentLoaded","Load","Custom","FullSnapshot","MouseInteraction","TouchMove","MediaInteraction","ViewportResize","StyleSheetRule","Scroll","Input","needCastInSyncMode","castFn","EventCast","neededEvents_1","Flush","addActions","resetLastPlayedEvent","startLive","toggleLiveMode","addEvent","machineEvent","event_1","insertionIndex","castFn_1","isActive","addAction","mittProxy.default","mittProxy","defaultMouseTailConfig","duration","lineCap","lineWidth","strokeStyle","defaultLogConfig","level","replayLogger","defaultConfig","maxSpeed","root","loadTimeout","skipInactive","showWarning","showDebug","blockClass","insertStyleRules","triggerFocus","UNSAFE_replayCanvas","pauseAnimation","mouseTail","logConfig","getConsoleLogger","handleResize","Resize","setupDom","treeIndex","fragmentParentMap","elementStateMap","flush","frag","restoreRealParent","applyScroll","applyInput","firstPlayedEvent","service","unpackFn","a1","a2","StateChange","player","speedService","normalSpeed","normal","FAST_FORWARD","SET_SPEED","skipping","BACK_TO_NORMAL","setSpeed","recordSpeed","restoreSpeed","firstMeta","find","firstFullsnapshot","width_1","height_1","setTimeout","rebuildFullSnapshot","iframe","contentWindow","initialOffset","Replayer","backToNormal","display","Number","parseFloat","classList","wrapper","insertBefore","firstEvent","lastEvent","endTime","totalTime","getTimeOffset","contentDocument","getElementsByTagName","remove","Start","Pause","Resume","rawEvent","Promise","resolve","then","pointerEvents","mouse","win","disableInteract","smoothscrollPolyfill","NodeList","DOMTokenList","Node","contains","dimension","String","CustomEvent","applyIncremental","nextUserInteractionEvent","_event","isUserInteraction","skipTime","min","round","SkipStart","finish_1","Finish","max","legacy_missingNodeRetryMap","collected","builtNode","collectIframeAndAttachDocument","mutationInQueue","this_1","attachDocumentToIframe","newDocumentQueue","documentElement_1","head_1","collected_1","head","FullsnapshotRebuilded","waitForStylesheetLoad","preloadAllImages","styleEl","injectStylesRules","sheet","insertRule","iframeEl","realParent","this_2","collected_2","timer_1","unloadSheets_1","beforeLoadState_1","stateHandler_1","unsubscribe_1","querySelectorAll","addEventListener","size","getCurrentTime","LoadStylesheetEnd","window","clearTimeout","LoadStylesheetStart","beforeLoadState","stateHandler","count","resolved","CanvasMutation","args","imageMap","image","text","attribute","applyMutation","lastPosition","moveAndHover","Event","toLowerCase","debugNodeNotFound","Blur","blur","Focus","focus","preventScroll","Click","TouchStart","TouchEnd","offsetWidth","dispatchEvent","input","mediaEl_1","Play","readyState","HTMLMediaElement","HAVE_CURRENT_DATA","message","usingVirtualParent","placeholderNode","domParent","replaceChild","styleSheet_1","_index","deleteRule","setter","warnCanvasMutationFailed","Font","fontFace","FontFace","family","buffer","Uint8Array","JSON","fontSource","descriptors","fonts","Log","logData_1","useVirtualParent","warnNodeNotFound","realTarget","legacy_missingNodeMap","appendNode","parentInDocument","hasIframeChild","virtualParent","createDocumentFragment","storeState","previous","previousId","nextNotInDOM","targetDoc","nextSibling","mutationInQueue_1","legacy_resolveMissingNode","resolveTrees","resolveTrees_1","debug","attributeName","removeAttribute","checked","isChecked","trace","result","log","formatMessage","targetMutation","previousInMap","nextInMap","base","getBaseDimension","rootIframe","frameElement","ownerDocument","defaultView","relativeScale","absoluteScale","frameDimension","frameBaseDimension","_x","_y","drawMouseTail","hoverElements","draw","tailPositions","clearRect","beginPath","moveTo","lineTo","stroke","hoveredEl","currentEl","parentElement","SkipEnd","restoreState","storedState","u8","u16","Uint16Array","u32","Uint32Array","fleb","fdeb","clim","freb","eb","j","fl","revfl","fd","rev","hMap","cd","mb","co","le","rvb","sv","r_1","flt","fdt","flrm","fdrm","bits","bits16","slc","subarray","crct","unzlibSync","out","dat","buf","st","sl","noBuf","noSt","cbuf","bl","nbuf","final","bt","lm","dm","lbt","dbt","tbts","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","lt","dt","lms","dms","mxa","sym","dsym","inflt","zlv","raw","latin1","TextDecoder","decode","fromCharCode","strFromU8","TextEncoder","encode","ai","charCodeAt","strToU8"],"mappings":"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"}